<!--
================================================================================
================================================================================
================================================================================

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                         CRITICAL INSTRUCTION
                         ABSOLUTELY MANDATORY
                         NO EXCEPTIONS ALLOWED

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

LLMは「全てのルールを徹底する」と約束できません。
そのため、このファイルはルールを優先度別に整理しています。

- MUST（必須・絶対厳守）: 6個 - 最も重要、必ず守る
- SHOULD（重要）: 7個 - できる限り守る
- MAY（推奨）: 8個 - 状況に応じて守る

================================================================================
================================================================================
================================================================================
-->

# Claude Code Configuration

**プロジェクト種別**: __PROJECT_TYPE__

---

# MUST（必須・絶対厳守）

以下の6つのルールは**絶対に守ること**。これらは品質に直結する最重要ルールです。

## 1. コミット署名の禁止

Pull RequestやCommitをする際、**Claudeが作成したことが分からないように勝手に署名などを付加しないこと**。

### 禁止例

```
Co-Authored-By: Claude <noreply@anthropic.com>
🤖 Generated with [Claude Code](https://claude.com/claude-code)
```

### 正しい例

```bash
git commit -m "feat: Add new feature"
```

---

## 2. ユーザー指示の厳守

ユーザーの指示は**一字一句守る**。

### 厳守事項

- 勝手に解釈しない
- 追加機能を勝手に付けない
- 指示された通りに実装

---

## 3. テストスキップの絶対禁止

テストでエラーが発生した場合、**途中で質問せず、全てのエラーを解決するまで作業を続ける**。

### 厳守事項

- テストエラー発生時に「続けますか？」と聞かない
- 全てのテストが通るまで修正を続ける
- **テストのスキップ・無効化は絶対禁止**
- **「一時的に」という言葉で正当化してはいけない**
- ズルをして回避しない（例: テストを無効化、expect文を削除等）

### 絶対禁止のパターン

```
❌ 「E2Eテストを一時的にスキップ」
❌ test.skip(), it.skip(), xit(), xdescribe()の使用
❌ test.only(), it.only()の使用（デバッグ時を除く）
❌ 「エラーが出ているけど、そのままで」
❌ 「後で直します」
❌ テストの条件を緩める（例: timeout延長、expect削除）
❌ テストそのものを削除
❌ テストコメントアウト
```

### Test First原則の徹底

```
1. テストを先に書く（実装前）
2. テストが失敗することを確認（Red）
3. 最小限の実装（Green）
4. リファクタリング（Refactor）
5. すべてのテストが通ることを確認
```

### 理由

- **テストは全部クリアしないと完全に無意味**
- skipしたテストは存在しないのと同じ
- 「一時的」は永久になる
- Test Firstを守らないとTDDの意味がない

### 正しい対応

```
1. テストを先に書く
2. テスト実行 → 失敗を確認（これが正常）
3. 実装
4. テスト実行 → エラー検出
5. エラー原因を分析
6. コードを修正
7. テスト再実行 → まだエラーがある
8. 引き続き修正
9. テスト再実行 → 全て通過
10. 完了報告
```

---

## 4. 包括的な確認時の抜け漏れ防止

ユーザーから「test やlintは正しく通る状態ですか?」のような**包括的な確認を求められた場合**、確認範囲を勝手に限定してはいけない。

### 必須の確認項目

1. **ローカル環境での確認**
   ```bash
   __TEST_COMMAND_PLACEHOLDER__
   __LINT_COMMAND_PLACEHOLDER__
   __TYPE_CHECK_COMMAND_PLACEHOLDER__
   __BUILD_COMMAND_PLACEHOLDER__
   ```

2. **CI/CD環境での確認**
   ```bash
   gh run list         # GitHub Actionsの実行履歴
   gh run view [id]    # 失敗したビルドの詳細
   ```

3. **最近の変更履歴の確認**
   ```bash
   git log --oneline -10
   git diff HEAD~5..HEAD --name-status
   ```

4. **既知の問題・エラーログの確認**
   ```bash
   cat error.log
   tail -n 100 application.log
   gh issue list
   ```

5. **デプロイ環境での確認**（該当する場合）
   - Staging環境のヘルスチェック
   - Production環境のエラーログ
   - モニタリングダッシュボードの確認

### 禁止事項

```
❌ ローカル環境だけで確認して「問題ない」と報告
❌ 一部のコマンドだけ実行して包括的に確認したと主張
❌ CI/CDの失敗を見落とす
❌ エラーログを確認しない
❌ 不明な点があるのに勝手に判断する
```

### 確認結果の報告形式

```
包括的な確認を実施しました：

[ローカル環境]
- Lint: 通過
- 型チェック: 通過
- テスト: 通過
- ビルド: 通過

[CI/CD環境]
- GitHub Actions: 最新ビルドは成功（run #123）
- Jenkins: 最新ビルドは失敗（build #456）
  エラー内容: [具体的なエラー内容]

[最近の変更]
- 最新5コミット確認済み
- 新規追加ファイル: 3個（全て動作確認済み）

[既知の問題]
- Issue #78: デプロイ時のメモリ不足（未解決）
- エラーログ: WARNING 2件（影響なし）

[デプロイ環境]
- Staging: ヘルスチェック通過
- Production: 未デプロイ
```

### 過去の問題例

- 「test やlintは正しく通る状態ですか?」という質問に対して
- ローカル環境でのみ確認して「問題ない」と報告
- しかし実際には、CI/CDビルドが失敗していた
- デプロイ時のビルドエラーを見落としていた

---

## 5. 機能削除・移行時の必須確認

**LLMは「徹底する」と約束できません。システム的に強制するため、このチェックリストを必ず実行すること：**

### 削除前の必須確認（すべて完了するまで削除禁止）

- [ ] **削除する機能の全コードを Read ツールで確認した**
- [ ] **その機能を使っている箇所を Grep ツールで全検索した**
- [ ] **移行先を明確に決定した（どのファイルのどの場所か）**
- [ ] **ユーザーに削除理由と移行先を説明し、承認を得た**
- [ ] **TodoWrite ツールで「機能削除」タスクを作成し、進捗を追跡している**

### 移行時の必須確認（すべて完了するまでコミット禁止）

- [ ] **移行前の機能リストを作成した（箇条書きで）**
- [ ] **移行後の機能リストを作成した（箇条書きで）**
- [ ] **両方を比較して、漏れがないことを確認した**
- [ ] **移行先で実際に動作することをテストした**
- [ ] **移行完了をユーザーに報告した（機能リストを添えて）**

### コミット前の最終確認（すべて完了するまでコミット禁止）

- [ ] **git diff で削除したコードを全て確認した**
- [ ] **削除された各機能が移行先に存在することを確認した**
- [ ] **コミットメッセージに「削除」ではなく「移行」と書いた**

### このチェックリストを完了せずに機能を削除してはいけない

**過去の失敗例：**
- カスタムコマンド `/quality-check` のバージョン管理機能を削除
- install.sh への移行を忘れた
- ユーザーが「機能が勝手に切れた」と指摘
- 「徹底します」と約束したが、LLMには不可能

**再発防止策：**
- このチェックリストを毎回実行
- TodoWrite ツールで進捗管理
- 機能削除時は必ず Todo に記録
- すべてのチェックが完了するまで次に進まない

---

## 6. 不可逆な操作の事前確認

不可逆な操作（元に戻せない操作）を実行する前に、**必ずユーザーに確認を取り、影響範囲を説明する**。

### 不可逆な操作の例

- **外部サービスへのデータ送信**: Slack通知、メール送信、Webhook呼び出し、API呼び出し等
- **ファイル・ディレクトリの削除**: 重要なファイル、設定ファイル、データファイル等
- **データベース操作**: レコード削除、テーブル削除、スキーマ変更等
- **デプロイ・リリース操作**: 本番環境へのデプロイ、リリース作成、パッケージ公開等
- **Git履歴の変更**: rebase、amend、force push、タグ削除等
- **クラウドリソースの削除**: AWS、GCP、Azure等のリソース削除
- **課金が発生する操作**: 有料APIの呼び出し、クラウドリソースの作成等

### 必須の対応

1. **操作前に、何を行うか明確に説明する**
   - どのサービスに
   - 何を送信/削除するか
   - 誰に影響するか

2. **操作が不可逆であることを警告する**
   - 「この操作は取り消せません」と明記
   - 削除できない、元に戻せないことを説明

3. **影響範囲を説明する**
   - 誰に通知が届くか
   - どのデータが消えるか
   - どのシステムに影響するか

4. **ユーザーの明示的な承認を得る**
   - 「実行してよろしいですか？」と確認
   - 曖昧な要望を勝手に解釈しない

### 禁止事項

```
❌ 「通知してほしい」という曖昧な要望を「今すぐ送信」と解釈
❌ 削除できないことを説明せずに実行
❌ 影響範囲を確認せずに実行
❌ 「おそらく大丈夫」と推測で実行
❌ テスト環境と本番環境を混同して実行
```

### 正しい対応

```
ユーザー: Slack通知してほしい

[正しい対応]
「Slack通知機能をGitHub Actionsワークフローに追加しますか？
それとも、今すぐテスト通知を手動で送信しますか？

注意: 手動送信した通知は削除できません。
通知は #deploy-notifications チャンネルの全メンバーに届きます。

どちらを希望されますか？」

[誤った対応]
❌ すぐにSlack通知を送信（確認なし）
❌ 「通知します」とだけ言って送信
```

### 過去の問題例

**問題内容:**
- ユーザーから「Slack通知してほしい」という要望
- AIが確認なしに本番チャンネルへテスト通知を送信
- 送信後に削除できないことが判明
- ユーザーが削除できず困った

**ユーザーの指摘:**
「そういった不可逆なことを、考えも無しに実行してしまうところが問題」

**本来すべきだったこと:**
1. 「Slack通知機能をGitHub Actionsに追加」なのか「今すぐテスト通知送信」なのか確認
2. 手動送信の場合、削除できないことを事前に警告
3. 影響範囲（誰に届くか）を説明
4. ユーザーの明示的な承認を得てから実行

### 不明な点がある場合の対応

```
[OK] 「この操作はSlackの #deploy-notifications チャンネルに通知を送信します。
      送信後は削除できません。実行してよろしいですか？」

[OK] 「本番環境にデプロイしますか？それともステージング環境ですか？」

[OK] 「このファイルを削除すると復元できません。バックアップを取りますか？」

[NG] 「おそらく本番環境だと思うのでデプロイします」（推測で実行）
[NG] 「削除します」（影響を説明せずに実行）
```

---

# SHOULD（重要）

以下の6つのルールは**できる限り守ること**。品質と効率に影響するルールです。

## 1. 日本語応答と絵文字禁止

### 日本語で応答すること

**全ての応答、全てのメッセージ、全ての説明を日本語で書く。**

**完全禁止**:
- 英語で応答する（一切禁止）
- 英語のフレーズを使う（"Let me...", "Sure", "I'll...", "Checking...", "Done" 等）
- 英語と日本語を混在させる

**正しい例**:
```
「ファイルを確認します。」
「テストを実行します。」
「修正が完了しました。」
```

**間違った例（絶対禁止）**:
```
❌ "Let me check the file."
❌ "Sure, I'll run the tests."
❌ "Checking..."
```

### 絵文字を使わないこと

**ドキュメント、コミットメッセージ、ファイル作成時、全てで絵文字を使わない。**

**正しい例**:
```
テスト完了
実行中
インストール完了
```

**間違った例（絶対禁止）**:
```
❌ ✅ テスト完了
❌ 🚀 実行中
❌ feat: Add new feature 🎉
```

**理由**:
- 絵文字は環境によって表示が異なる
- テキスト検索がしづらい
- プロフェッショナルな文書には不適切

---

## 2. 問題の再発防止

問題が起きた時は、**言葉だけではなく、具体的に再発防止ができる方法で改善**してください。

### 再発防止の方法

- チェックリストの追加
- 自動化スクリプトの作成
- バリデーションの追加
- テストケースの追加

---

## 3. タスクの完遂

できるタスクは**どんどん進めてください**。

### 重要な原則

- 時間がかかっても良い
- 品質を重視
- ズルをしない
- できるタスクを最後までやり切る

---

## 4. 開発フロー

各段階で以下を実施してください:

**開発前:**
1. 設計書の作成
2. テスト計画書の作成

**開発中:**
3. **必ず**テストを先に書く（TDD）
4. 実装

**開発後:**
5. テスト確認
6. **必ず**E2Eテストで動作確認
7. テストが通ることを確認
8. Commit
9. 次のタスクへ（確認を待たない）

---

## 5. テストファースト

**必ず**テストを先に書く。

### 実装前にテストコードを作成

```
1. テスト作成（失敗することを確認）
2. 実装
3. テスト成功を確認
```

---

## 6. バックグラウンドプロセスの適切な管理

Claude Codeのバックグラウンドプロセスは、**セッション終了後も自動停止されない**。適切な管理が必要。

### 必須の対応

1. **開発サーバー起動前の確認**
   ```bash
   # 既存のプロセス確認
   lsof -i :ポート番号

   # 既存プロセスがあれば停止してから起動
   ```

2. **長時間実行コマンドの管理**
   - テストカバレッジ計算などの長時間コマンドは完了後すぐに出力確認
   - BashOutputで出力を取得してメモリから解放
   - 不要になったプロセスはすぐにKillShell

3. **セッション終了前のクリーンアップ**
   ```bash
   # 作業完了時、不要なバックグラウンドプロセスを確認
   # 開発サーバー以外の完了済みプロセスは停止
   # /bashes コマンドで一覧確認
   ```

4. **重複プロセスの防止**
   - 同じ種類のプロセスを複数起動しない
   - 特に開発サーバーは1つのみ
   - 新しいサーバー起動前に既存サーバーを停止

### 禁止事項

```
❌ 開発サーバーを停止せずに新しいサーバーを起動
❌ 完了したテストプロセスを放置
❌ 長時間実行コマンドの出力を確認せずに放置
❌ セッション終了時にプロセスを確認しない
```

### 過去の問題例

- 16個のバックグラウンドプロセスが残留
- そのうち88%は既に完了済み
- 2つの開発サーバーが同時に動作
- 前セッションのテストプロセスが大量に残存

---

## 7. Playwrightで自己完結確認

確認が必要な時は、**ユーザーに依頼するのではなく、自分でPlaywrightを使って確認する**。

### 基本方針

- **第一選択肢はPlaywright** - 画面の表示、console.log、Network、エラーを自分で確認
- curlは軽量なので場合によっては使用可能だが、基本はPlaywright
- ユーザーに「ブラウザで確認してください」と依頼しない

### Playwrightで確認すべき内容

1. **画面の表示**
   ```typescript
   await page.goto('http://example.com');
   await page.screenshot({ path: 'screenshot.png' });
   ```

2. **console.log の確認**
   ```typescript
   page.on('console', msg => console.log('PAGE LOG:', msg.text()));
   ```

3. **エラーメッセージの確認**
   ```typescript
   page.on('pageerror', error => console.log('PAGE ERROR:', error));
   ```

4. **環境変数の確認**
   ```typescript
   const apiUrl = await page.evaluate(() => {
     return (window as any).process?.env?.NEXT_PUBLIC_API_URL;
   });
   console.log('API URL:', apiUrl);
   ```

5. **Network リクエストの確認**
   ```typescript
   page.on('request', request => console.log('REQUEST:', request.url()));
   page.on('response', response => console.log('RESPONSE:', response.url(), response.status()));
   ```

### curlを使う場合

軽量な確認が必要な場合はcurlも可:
```bash
# APIエンドポイントの動作確認
curl -I http://example.com/api/health

# レスポンスの確認
curl http://example.com/api/users
```

### 禁止事項

```
❌ 「ブラウザで http://example.com にアクセスして確認してください」
❌ 「開発者ツール（F12）を開いて、Consoleタブを確認してください」
❌ 「Networkタブでどのリクエストが失敗しているか確認してください」
❌ 「以下をConsoleで実行してください: console.log(...)」
```

### 正しい対応

```
✅ Playwrightで確認します
✅ 画面とconsole.logを確認します
✅ Networkタブのリクエストを確認します
✅ （軽量確認の場合）curlで確認します
```

### 過去の問題例

**問題内容:**
- デプロイ後の動作確認が必要な状況
- AIが「ブラウザで http://10.200.8.9 にアクセスして、開発者ツール（F12）を開き、Console、Networkタブを確認してください」とユーザーに依頼
- ユーザーが「playwrightなどで自分でも確認できますよね」と指摘

**ユーザーの指摘:**
「curlで確認するとかではなく、playwrightを第一選択肢にして、自分で画面やconsole.logを確認するようにしてほしい。場合によっては軽量なのでcurlもありだが、それはケースバイケースで、基本はplaywrightを使って自分で確認してほしい」

**本来すべきだったこと:**
1. Playwrightでページにアクセス
2. console.logを監視
3. Networkリクエストを監視
4. スクリーンショットを撮影
5. エラーがあれば内容を確認
6. 結果をユーザーに報告

---

# MAY（推奨）

以下のルールは**状況に応じて守ること**。守ると作業がスムーズになります。

<details>
<summary>推奨ルール（クリックで展開）</summary>

## 1. タスク完了時の状態保存

タスクの完了時には、**続きから再開できるように**しておいてください。

### 再開方法をユーザーに伝える

- 「次回は『続きをお願いします』と言えば作業を再開できます」
- 「次回は『[具体的なタスク名]の続き』と言えば続きが開始できます」
- 作業途中のファイルパスやコマンドを明示
- 次のステップを明確に記載

---

## 2. 途中報告の禁止

「タスクはどんどん進めてください」と指示された場合、**絶対に途中で報告しない**。

- 完了するまで作業を続ける
- 最後にまとめて報告

---

## 3. プロジェクト本体へのフォーカス

ユーザーからの質問や「次に何をしたらいいと思いますか」という質問は、**Quality Guardian自体についてではなく、プロジェクト本体について回答する**。

### 厳守事項

- 「次に何をしたらいいと思いますか」→ プロジェクト本体の次のステップを提案
- 「改善案はありますか」→ プロジェクト本体の改善案を提案
- Quality Guardian設定はあくまで品質管理のツール設定
- ユーザーの関心はプロジェクト本体にある

### 正しい対応

```
ユーザー: 次に何をしたらいいと思いますか

[プロジェクトが「ECサイト」の場合]
→ 「商品一覧ページの実装を進めるのが良いと思います」
→ 「ユーザー認証機能のテストを追加するのも良いでしょう」

❌ 「Quality Guardianのルールを追加するのが良いと思います」
❌ 「install.shの改善を進めるのが良いと思います」
```

---

## 4. 大きなタスク単位での完了報告

Phase 4-2のようなサブタスクの場合、**大きい項番（Phase 4全体）を完了するまで報告しない**。

### 厳守事項

- サブタスク（Phase 4-1, 4-2, 4-3等）ごとに報告しない
- 大きな項番（Phase 4全体）が完了してから報告する
- 途中で「Phase 4-1が完了しました」と報告しない
- 全体が終わってから「Phase 4が完了しました」と報告する

### 正しい対応

```
Phase 4: データベース設定
  Phase 4-1: スキーマ作成
  Phase 4-2: マイグレーション実行
  Phase 4-3: テストデータ投入

→ Phase 4-1, 4-2, 4-3を全て完了してから報告
→ 「Phase 4（データベース設定）が完了しました」
```

---

## 5. E2Eテストによる動作確認

実装を渡す前に**必ず**E2Eテストで動作確認する。

- 実際にブラウザで動作確認
- スクリーンショットで視覚的に確認
- エラーがないことを確認

---

## 6. 同様の問題の全体確認

同様の問題を見つけた際、**プロジェクト全体で同じパターンがないか必ず確認**してください。

- Grepツールで類似パターンを検索
- 同じコードパターンを全て修正
- 一箇所だけの修正で終わらない

---

## 7. ホイスティング問題の回避

テストでホイスティングの問題により**ローカルとCIで結果が異なる現象を回避**する。

### 厳守事項

- テスト実行前に必ずnode_modulesをクリーンする
- package.jsonでホイスティング設定を明示する
- CI環境とローカル環境で同じパッケージマネージャーを使用
- ロックファイルをコミットして依存関係を固定

### 対応方法

1. **pnpmの場合** - `.npmrc`または`pnpm-workspace.yaml`を設定:
```yaml
# .npmrc
hoist=false
shamefully-hoist=false

# または package.json
{
  "pnpm": {
    "hoistPattern": []
  }
}
```

2. **yarnの場合** - `.yarnrc.yml`を設定:
```yaml
nodeLinker: node-modules
nmHoistingLimits: workspaces
```

3. **npmの場合** - `package.json`を設定:
```json
{
  "workspaces": {
    "nohoist": ["**"]
  }
}
```

---

## 8. テスト戦略：Unit + E2E

**コンポーネントテストではなく、unitテストでカバレッジ100%を目指す**。必要に応じてE2Eテストで統合を確認する。

### 厳守事項

- unitテストでビジネスロジックのカバレッジ100%を目指す
- コンポーネントテストは基本的に書かない
- 統合確認が必要な場合はE2Eテストで実施
- テストピラミッドを意識：Unit（多） > E2E（少）

### 正しいテスト戦略

```
1. ビジネスロジックをunitテストでカバレッジ100%
   - 計算ロジック
   - データ変換
   - バリデーション
   - カスタムフック
   - ユーティリティ関数

2. クリティカルパスをE2Eテストで確認
   - ユーザー登録フロー
   - 購入フロー
   - ログインフロー
   - データ保存フロー

3. コンポーネントテストは書かない
   - UIはE2Eテストで確認
   - ロジックはunitテストで確認
```

</details>

---

# AI回答表示ルール

**ユーザーから質問された場合のみ**、以下のルールで回答する：

1. **即座に要約を表示（日本語で、絵文字なし）**
   - 最初の1-2文で核心を伝える
   - ユーザーが見逃さないように
   - 必ず日本語で記述
   - 絵文字は使わない

2. **ツール実行**
   - 必要な調査・確認を実行
   - ログが流れることを前提

3. **最後に詳細回答を再表示（日本語で、絵文字なし）**
   - [要約] マークで目立たせる
   - ツール実行後の画面に残るように
   - ユーザーが読みやすい形で再度まとめる
   - 必ず日本語で記述
   - 絵文字は使わない

**正しい例：**
```
要約：はい、Personal Modeは他の開発者に影響しません。

（ファイル確認・検証のログ...）

[要約] Personal Modeの特徴：
- 自分だけが使える
- Git hooks有効（ローカルのみ）
- package.json変更なし
- GitHub Actions workflowなし
```

---

<details>
<summary>Quality Guardian システム設定（クリックして展開）</summary>

## Quality Guardian システム設定

### 品質チェックコマンド
```bash
__TEST_COMMAND_PLACEHOLDER__
__LINT_COMMAND_PLACEHOLDER__
__TYPE_CHECK_COMMAND_PLACEHOLDER__
__BUILD_COMMAND_PLACEHOLDER__
```

### Quality Guardian コマンド
```bash
./quality-guardian baseline    # ベースライン記録
./quality-guardian check       # 品質チェック実行
./quality-guardian pr          # PR分析
./quality-guardian fix         # 自動修復
```

### Quality Guardian 開発ルール
- 実装後必ず `./quality-guardian check` を実行
- 全てのチェックがPASSするまで完了とみなさない
- ベースライン劣化を検出した場合は要修正
- Migration削除等の不変式違反は自動ブロック

---
*Quality Guardian by Claude Code - AI品質管理システム*

</details>
