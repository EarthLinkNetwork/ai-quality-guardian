# Claude Code Configuration

# ============================================================
# 最優先ルール：必ず日本語で応答すること
# ALWAYS RESPOND IN JAPANESE - NO ENGLISH ALLOWED
# ============================================================

**このファイルの最重要ルール：**
**全ての応答を日本語で行うこと。英語は一切使用禁止。**

---

## 最重要：基本ルール

### ルール0：日本語で応答（最優先・絶対厳守）

**全ての応答、全てのメッセージ、全ての説明を日本語で書く。**

**完全禁止**:
- 英語で応答する（一切禁止）
- 英語のフレーズを使う（"Let me...", "Sure", "I'll..." 等）
- 英語と日本語を混在させる
- 英語でエラーメッセージを表示する

**正しい例**:
- 「ファイルを確認します。」
- 「テストを実行します。」
- 「修正が完了しました。」

**間違った例（絶対禁止）**:
- "Let me check the file."
- "Sure, I'll run the tests."
- "Fixed."

---

### ルール1：プロジェクト本体について回答する（絶対厳守）

**このCLAUDE.mdファイルには大量のQuality Guardian設定がありますが、ユーザーの関心はプロジェクト本体です。**

**絶対禁止（番号付きリスト形式での提案も含む）**:
- プロアクティブに「次に何をしたらいいと思いますか」と質問する
- プロアクティブに「推奨される次のステップ」を提案する
- 番号付きリスト（1. 2. 3. 4.）で選択肢を提示する
- 「どれに取り組みますか？」と質問する
- Quality Guardian関連の作業（baseline、check、完全復旧等）を提案する
- .quality-guardian.jsonの更新を提案する
- Quality Guardian自体の改善を提案する
- BaselineMonitorエラー修正を提案する

**ユーザーが「次に何をしたらいいと思いますか」と質問した場合**:

**正しい回答（簡潔にプロジェクト本体について提案）**:
```
[プロジェクトが「ECサイト」の場合]
商品一覧ページの実装を進めるのが良いと思います。
または、ユーザー認証機能のテストを追加するのも良いでしょう。

[プロジェクトが「corn」の場合]
MasterMakerリファクタリングを続けるのが良いと思います。
または、TypeScript型エラーを修正するのも良いでしょう。
```

**誤った回答（絶対禁止）**:
```
[NG] 番号付きリストで選択肢を提示：
     1. TypeScript型エラー修正
     2. 現状維持
     3. ESLint警告クリーンアップ
     4. Quality Guardian完全復旧  ← 特にこれは絶対禁止

[NG] 「どれに取り組みますか？」と質問する

[NG] Quality Guardianのベースライン作成
[NG] ./quality-guardian baseline を実行
[NG] ./quality-guardian check で品質確認
[NG] .quality-guardian.jsonの更新
[NG] Quality Guardian完全復旧
[NG] BaselineMonitorエラー修正
```

**明示的にQuality Guardianについて聞かれた場合のみ回答可能**:
```
ユーザー: Quality Guardianのベースラインを作成したい
→ これはOK（Quality Guardianについて明示的に質問している）

ユーザー: 次に何をしたらいいと思いますか
→ プロジェクト本体について回答（Quality Guardian提案は禁止）
```

---

## AI回答表示ルール

**重要：全ての応答は日本語で行う。英語での応答は禁止。**

**ユーザーから質問された場合のみ**、以下のルールで回答する：

1. **即座に要約を表示（日本語で）**
   - 最初の1-2文で核心を伝える
   - ユーザーが見逃さないように
   - 必ず日本語で記述

2. **ツール実行**
   - 必要な調査・確認を実行
   - ログが流れることを前提

3. **最後に詳細回答を再表示（日本語で）**
   - [要約] マークで目立たせる
   - ツール実行後の画面に残るように
   - ユーザーが読みやすい形で再度まとめる
   - 必ず日本語で記述

**正しい例：**
```
要約：はい、Personal Modeは他の開発者に影響しません。

（ファイル確認・検証のログ...）

[要約] Personal Modeの特徴：
- 自分だけが使える
- Git hooks有効（ローカルのみ）
- package.json変更なし
- GitHub Actions workflowなし
```

**誤った例（英語での応答）：**
```
[NG] Summary: Yes, Personal Mode does not affect other developers.
[NG] Let me check the file...
[NG] Summary: Personal Mode features:
```

---

## AI開発の必須ルール（厳守）

### 1. 問題の再発防止
問題が起きた時は、**言葉だけではなく、具体的に再発防止ができる方法で改善**してください。
- チェックリストの追加
- 自動化スクリプトの作成
- バリデーションの追加
- テストケースの追加

### 2. コミット署名の禁止（とても重要）
Pull RequestやCommitをする際、**Claudeが作成したことが分からないように勝手に署名などを付加しないでください**。

禁止例:
```
Co-Authored-By: Claude <noreply@anthropic.com>
Generated with [Claude Code](https://claude.com/claude-code)
```

正しい例:
```
git commit -m "feat: Add new feature"
```

### 3. タスク完了時の状態保存
タスクの完了時には、**続きから再開できるように**しておいてください。

再開方法をユーザーに伝える:
- 「次回は『続きをお願いします』と言えば作業を再開できます」
- 「次回は『[具体的なタスク名]の続き』と言えば続きが開始できます」
- 作業途中のファイルパスやコマンドを明示
- 次のステップを明確に記載

### 4. タスクの完遂
できるタスクは**どんどん進めてください**。

重要な原則:
- 時間がかかっても良い
- 品質を重視
- ズルをしない
- できるタスクを最後までやり切る

### 5. テストはPlaywrightで実施
テストは**curlではなくPlaywright**を使用してください。

必須の確認項目:
- Playwrightでスクリーンショット確認
- console.logを確認
- 実際のブラウザ動作を確認

### 6. 同様の問題の全体確認
同様の問題を見つけた際、**プロジェクト全体で同じパターンがないか必ず確認**してください。

- Grepツールで類似パターンを検索
- 同じコードパターンを全て修正
- 一箇所だけの修正で終わらない

### 7. 開発フローの厳守
各段階で以下を実施してください:

**開発前:**
1. 設計書の作成
2. テスト計画書の作成

**開発中:**
3. **必ず**テストを先に書く（TDD）
4. 実装

**開発後:**
5. テスト確認
6. **必ず**E2Eテストで動作確認
7. テストが通ることを確認
8. Commit
9. 次のタスクへ（確認を待たない）

### 8. 途中報告の禁止
「タスクはどんどん進めてください」と指示された場合、**絶対に途中で報告しない**。

- 完了するまで作業を続ける
- 最後にまとめて報告

### 9. ユーザー指示の厳守
ユーザーの指示は**一字一句守る**。

- 勝手に解釈しない
- 追加機能を勝手に付けない
- 指示された通りに実装

### 10. テストファーストの徹底
**必ず**テストを先に書く。

実装前にテストコードを作成:
```
1. テスト作成（失敗することを確認）
2. 実装
3. テスト成功を確認
```

### 11. E2Eテストによる動作確認
実装を渡す前に**必ず**E2Eテストで動作確認する。

- 実際にブラウザで動作確認
- スクリーンショットで視覚的に確認
- エラーがないことを確認

### 12. 絵文字の禁止
ドキュメントやコミットメッセージに**絵文字を使わない**。

禁止例:
```
# ドキュメント
[OK] インストール完了
[NEW] 新機能追加
[DOC] ドキュメント更新

# コミットメッセージ
feat: Add new feature
fix: Fix bug
```

**理由**:
- 絵文字は環境によって表示が異なる
- テキスト検索がしづらい
- プロフェッショナルな文書には不適切

### 13. 日本語での応答を厳守（絶対厳守）

**全ての応答を日本語で行う。英語での応答は完全禁止。**

**絶対禁止事項**:
- 英語で応答する
- 英語と日本語を混在させる
- エラーメッセージを英語で表示する
- コマンド結果の説明を英語で行う
- 「Sure, I'll...」「Let me...」などの英語フレーズを使う

**正しい応答**:
```
[OK] 「テストが全て通過しました。」
[OK] 「ファイルを読み込んで確認します。」
[OK] 「エラーが発生しました：ファイルが見つかりません」
[OK] 「次のコマンドを実行します：npm test」
```

**誤った応答**:
```
[NG] "Sure, I'll run the tests."
[NG] "Let me check the file."
[NG] "Error: File not found"
[NG] "Running command: npm test"
[NG] "I'll help you with this."
```

**完了報告も日本語のみ**:
```
[OK] 「v1.2.29のリリースが完了しました。」
[OK] 「バグを修正しました。」
[OK] 「テストスイートを追加しました。」

[NG] "v1.2.29 release completed."
[NG] "Fixed the bug."
[NG] "Added test suite."
```

**理由**:
- ユーザーは日本語での応答を期待している
- 英語での応答はユーザーの読解速度を遅くする
- 日本語と英語が混在すると読みにくい
- コミュニケーションの一貫性を保つため

### 14. テストエラーの完全解決（絶対厳守）
テストでエラーが発生した場合、**途中で質問せず、全てのエラーを解決するまで作業を続ける**。

**厳守事項**:
- テストエラー発生時に「続けますか？」と聞かない
- 全てのテストが通るまで修正を続ける
- テストのskipは許容しない
- ズルをして回避しない（例: テストを無効化、expect文を削除等）
- 途中で質問せず、最後まで修正を完了させる

**理由**:
- テストは全部クリアしないと意味がない
- 途中で質問するのは無意味
- skipしても仕方ない（意味がない）
- ズルをして回避するものではない

**正しい対応**:
```
1. テスト実行 → エラー検出
2. エラー原因を分析
3. コードを修正
4. テスト再実行 → まだエラーがある
5. 引き続き修正
6. テスト再実行 → 全て通過
7. 完了報告
```

**誤った対応**:
```
[NG] テスト実行 → エラー検出 → 「続けますか？」と質問
[NG] テスト実行 → エラー検出 → テストをskip
[NG] テスト実行 → エラー検出 → テストを無効化
[NG] テスト実行 → エラー検出 → expect文を削除
```

### 15. 大きなタスク単位での完了報告（厳守）
Phase 4-2のようなサブタスクの場合、**大きい項番（Phase 4全体）を完了するまで報告しない**。

**厳守事項**:
- サブタスク（Phase 4-1, 4-2, 4-3等）ごとに報告しない
- 大きな項番（Phase 4全体）が完了してから報告する
- 途中で「Phase 4-1が完了しました」と報告しない
- 全体が終わってから「Phase 4が完了しました」と報告する

**理由**:
- サブタスクごとの報告は無駄なやりとりを増やす
- ユーザーは大きなタスク単位での完了を期待している
- 細かい進捗報告は不要

**正しい対応**:
```
Phase 4: データベース設定
  Phase 4-1: スキーマ作成
  Phase 4-2: マイグレーション実行
  Phase 4-3: テストデータ投入

→ Phase 4-1, 4-2, 4-3を全て完了してから報告
→ 「Phase 4（データベース設定）が完了しました」
```

**誤った対応**:
```
[NG] Phase 4-1完了 → 報告 → Phase 4-2実行 → 報告 → Phase 4-3実行 → 報告
[OK] Phase 4-1, 4-2, 4-3を全て実行 → Phase 4完了を報告
```

### 16. プロジェクト本体へのフォーカス（絶対厳守）

**作業完了後、絶対にプロアクティブな提案や質問をしない。**
**ユーザーが質問した場合も、Quality Guardian関連の作業を提案してはいけない。**

**絶対禁止事項**:
- プロアクティブに「次に何をしたらいいと思いますか」と質問する
- プロアクティブに「推奨される次のステップ」を提案する
- Quality Guardian関連の作業を提案する（baseline、check、設定更新等）
- .quality-guardian.json の更新を提案する
- Quality Guardian自体の改善を提案する

**正しい対応（作業完了後）**:
```
作業完了 → 完了報告のみ → 終了

[OK] 「テストが全て通過しました。」
[OK] 「実装が完了しました。」
[OK] 「バグを修正しました。」
```

**誤った対応（作業完了後）**:
```
[NG] 作業完了 → 「次に何をしたらいいと思いますか」と質問
[NG] 作業完了 → 「推奨される次のステップ」を提案
[NG] 作業完了 → 「Quality Guardianの改善」を提案
[NG] 作業完了 → 「どのステップから始めますか？」と質問
```

**ユーザーが「次に何をしたらいいと思いますか」と質問した場合**:

**正しい回答（プロジェクト本体について）**:
```
[プロジェクトが「ECサイト」の場合]
→ 「商品一覧ページの実装を進めるのが良いと思います」
→ 「ユーザー認証機能のテストを追加するのが良いと思います」
→ 「カート機能のバグを修正するのが良いと思います」

[プロジェクトが「corn」の場合]
→ 「MasterMakerリファクタリングを続けるのが良いと思います」
→ 「TypeScript型エラーを修正するのが良いと思います」
→ 「新機能の実装を進めるのが良いと思います」
```

**誤った回答（絶対禁止）**:
```
[NG] 「Quality Guardianのベースラインを作成するのが良いと思います」
[NG] 「./quality-guardian baseline を実行するのが良いと思います」
[NG] 「./quality-guardian check で品質確認するのが良いと思います」
[NG] 「.quality-guardian.json を更新するのが良いと思います」
[NG] 「Quality Guardianのルールを追加するのが良いと思います」
[NG] 「Quality Guardian完全復旧」を選択肢に含める
[NG] 「BaselineMonitorエラー修正」を提案する
[NG] 「git status を確認して整理するのが良いと思います」
[NG] 番号付きリスト形式で選択肢を提示する（1. 2. 3. 4.）
[NG] 「どれに取り組みますか？」と質問する
```

**明示的にQuality Guardianについて聞かれた場合のみ回答可能**:
```
ユーザー: Quality Guardianのベースラインを作成したい
→ OK（Quality Guardianについて明示的に質問している）

ユーザー: 次に何をしたらいいと思いますか
→ プロジェクト本体について回答（Quality Guardian提案は絶対禁止）
```

**理由**:
- ユーザーはプロジェクト本体の開発に集中したい
- Quality Guardian設定が大量にあるため、AIがそちらに引っ張られやすい
- プロアクティブな提案は作業の邪魔になる
- 必要な時にユーザーから明示的に質問してくる

### 17. ホイスティング問題の回避（厳守）
テストでホイスティングの問題により**ローカルとCIで結果が異なる現象を回避**する。

**厳守事項**:
- テスト実行前に必ずnode_modulesをクリーンする
- package.jsonでホイスティング設定を明示する
- CI環境とローカル環境で同じパッケージマネージャーを使用
- ロックファイルをコミットして依存関係を固定

**問題の原因**:
- monorepo/workspace環境で依存関係が親ディレクトリに巻き上げられる
- ローカルではキャッシュされたnode_modulesを使用するが、CIでは毎回クリーン
- パッケージマネージャーのバージョンやホイスティング設定が異なる

**対応方法**:

1. **pnpmの場合** - `.npmrc`または`pnpm-workspace.yaml`を設定:
```yaml
# .npmrc
hoist=false
shamefully-hoist=false

# または package.json
{
  "pnpm": {
    "hoistPattern": []
  }
}
```

2. **yarnの場合** - `.yarnrc.yml`を設定:
```yaml
nodeLinker: node-modules
nmHoistingLimits: workspaces
```

3. **npmの場合** - `package.json`を設定:
```json
{
  "workspaces": {
    "nohoist": ["**"]
  }
}
```

4. **テスト実行前のクリーン**:
```bash
# テスト前に必ず実行
rm -rf node_modules
pnpm install --frozen-lockfile  # または yarn install --frozen-lockfile、npm ci
pnpm test
```

5. **CIでの設定** - GitHub Actionsの例:
```yaml
- name: Clean install
  run: |
    rm -rf node_modules
    pnpm install --frozen-lockfile

- name: Run tests
  run: pnpm test
```

**理由**:
- ホイスティングによりテストの依存関係が不安定になる
- ローカルとCIで結果が異なるとデバッグが困難
- CI/CDパイプラインの信頼性が低下する

**正しい対応**:
```
1. node_modulesをクリーン
2. ロックファイルを使用して依存関係をインストール
3. テスト実行
4. テストが通ることを確認
5. ホイスティング設定をコミット
```

**誤った対応**:
```
[NG] ローカルでテストが通ったので、CIのエラーは無視
[NG] node_modulesをキャッシュしたままテスト
[NG] ロックファイルを更新せずにインストール
[NG] パッケージマネージャーのバージョンが異なる
```

### 18. テスト戦略：Unit + E2E（厳守）
**コンポーネントテストではなく、unitテストでカバレッジ100%を目指す**。必要に応じてE2Eテストで統合を確認する。

**厳守事項**:
- unitテストでビジネスロジックのカバレッジ100%を目指す
- コンポーネントテストは基本的に書かない
- 統合確認が必要な場合はE2Eテストで実施
- テストピラミッドを意識：Unit（多） > E2E（少）

**理由**:
- コンポーネントテストは中途半端で保守コストが高い
- unitテストは高速で実行でき、デバッグしやすい
- E2Eテストは実際のユーザー操作を再現できる
- 明確な役割分担により、テストが保守しやすくなる

**テスト戦略の比較**:

1. **Unit Test（推奨・多数）**:
```typescript
// ビジネスロジック、ユーティリティ関数、フック等
describe('calculateTotal', () => {
  it('should calculate total with tax', () => {
    expect(calculateTotal(100, 0.1)).toBe(110);
  });
});
```

利点:
- 高速実行（ミリ秒単位）
- 分離されており、デバッグしやすい
- カバレッジ計測が正確
- CI/CDで毎回実行可能

2. **Component Test（非推奨）**:
```typescript
// React Testing Libraryなど
render(<MyComponent />);
expect(screen.getByText('Hello')).toBeInTheDocument();
```

問題点:
- DOMのモックが必要で不安定
- 実行速度が遅い
- ユーザー操作の再現が不完全
- メンテナンスコストが高い

3. **E2E Test（推奨・少数）**:
```typescript
// Playwright
test('user can checkout', async ({ page }) => {
  await page.goto('/products');
  await page.click('[data-testid="add-to-cart"]');
  await page.click('[data-testid="checkout"]');
  await expect(page).toHaveURL('/checkout/complete');
});
```

利点:
- 実際のブラウザで動作確認
- ユーザー体験を正確に再現
- クリティカルパスの保証

**正しいテスト戦略**:
```
1. ビジネスロジックをunitテストでカバレッジ100%
   - 計算ロジック
   - データ変換
   - バリデーション
   - カスタムフック
   - ユーティリティ関数

2. クリティカルパスをE2Eテストで確認
   - ユーザー登録フロー
   - 購入フロー
   - ログインフロー
   - データ保存フロー

3. コンポーネントテストは書かない
   - UIはE2Eテストで確認
   - ロジックはunitテストで確認
```

**誤ったテスト戦略**:
```
[NG] コンポーネントテストで全てをカバーしようとする
[NG] unitテストを書かずにE2Eテストだけに頼る
[NG] テストピラミッドを逆転させる（E2E多、Unit少）
[NG] カバレッジ目標が曖昧（unitで100%を目指す）
```

**プロジェクト構成例**:
```
src/
  utils/
    calculator.ts
    calculator.test.ts        # unitテスト（カバレッジ100%）
  hooks/
    useCart.ts
    useCart.test.ts           # unitテスト（カバレッジ100%）
  components/
    ProductList.tsx
    # コンポーネントテストなし
tests/
  e2e/
    checkout.spec.ts          # E2Eテスト（クリティカルパス）
```

---

## 機能削除・移行時の必須確認（絶対厳守）

**LLMは「徹底する」と約束できません。システム的に強制するため、このチェックリストを必ず実行すること：**

### 削除前の必須確認（すべて完了するまで削除禁止）

- [ ] **削除する機能の全コードを Read ツールで確認した**
- [ ] **その機能を使っている箇所を Grep ツールで全検索した**
- [ ] **移行先を明確に決定した（どのファイルのどの場所か）**
- [ ] **ユーザーに削除理由と移行先を説明し、承認を得た**
- [ ] **TodoWrite ツールで「機能削除」タスクを作成し、進捗を追跡している**

### 移行時の必須確認（すべて完了するまでコミット禁止）

- [ ] **移行前の機能リストを作成した（箇条書きで）**
- [ ] **移行後の機能リストを作成した（箇条書きで）**
- [ ] **両方を比較して、漏れがないことを確認した**
- [ ] **移行先で実際に動作することをテストした**
- [ ] **移行完了をユーザーに報告した（機能リストを添えて）**

### コミット前の最終確認（すべて完了するまでコミット禁止）

- [ ] **git diff で削除したコードを全て確認した**
- [ ] **削除された各機能が移行先に存在することを確認した**
- [ ] **コミットメッセージに「削除」ではなく「移行」と書いた**
- [ ] **バージョンを更新した（3箇所：VERSION, install.sh, quality-guardian.js）**
- [ ] **README.md に変更内容を記載した**

### このチェックリストを完了せずに機能を削除してはいけない

**過去の失敗例：**
- カスタムコマンド `/quality-check` のバージョン管理機能を削除
- install.sh への移行を忘れた
- ユーザーが「機能が勝手に切れた」と指摘
- 「徹底します」と約束したが、LLMには不可能

**再発防止策：**
- このチェックリストを毎回実行
- TodoWrite ツールで進捗管理
- 機能削除時は必ず Todo に記録
- すべてのチェックが完了するまで次に進まない

---

<details>
<summary>Quality Guardian システム設定（クリックして展開）</summary>

## Quality Guardian システム設定

**プロジェクト種別**: __PROJECT_TYPE__

### 品質チェックコマンド
```bash
__TEST_COMMAND_PLACEHOLDER__
__LINT_COMMAND_PLACEHOLDER__
__TYPE_CHECK_COMMAND_PLACEHOLDER__
__BUILD_COMMAND_PLACEHOLDER__
```

### Quality Guardian コマンド
```bash
./quality-guardian baseline    # ベースライン記録
./quality-guardian check       # 品質チェック実行
./quality-guardian pr          # PR分析
./quality-guardian fix         # 自動修復
```

### Quality Guardian 開発ルール
- 実装後必ず `./quality-guardian check` を実行
- 全てのチェックがPASSするまで完了とみなさない
- ベースライン劣化を検出した場合は要修正
- Migration削除等の不変式違反は自動ブロック

---
*Quality Guardian by Claude Code - AI品質管理システム*

</details>
