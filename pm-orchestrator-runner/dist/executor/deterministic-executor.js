"use strict";
/**
 * Deterministic Executor for CLI_TEST_MODE
 *
 * Per spec 10_REPL_UX.md Section 11 and spec 06_CORRECTNESS_PROPERTIES.md Property 37:
 * When CLI_TEST_MODE=1, use deterministic stub instead of Claude Code CLI.
 *
 * This executor:
 * - Parses natural language prompts for file creation patterns
 * - Creates actual files on disk (verified_files exists=true)
 * - Performs filesBefore/filesAfter 2-scan (Property 31)
 * - Returns immediately without spawning subprocess
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeterministicExecutor = void 0;
exports.isDeterministicMode = isDeterministicMode;
exports.createExecutorForEnvironment = createExecutorForEnvironment;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
/**
 * File creation patterns detected from natural language
 */
const FILE_CREATION_PATTERNS = [
    // README patterns
    /readme/i,
    /create\s+readme/i,
    /作.*readme/i,
    // General file creation
    /create\s+(?:a\s+)?(?:file\s+)?(?:named?\s+)?(\S+\.\w+)/i,
    /make\s+(?:a\s+)?(?:file\s+)?(?:named?\s+)?(\S+\.\w+)/i,
    /write\s+(?:a\s+)?(?:file\s+)?(?:named?\s+)?(\S+\.\w+)/i,
    /生成\s*(\S+\.\w+)/i,
    /作成\s*(\S+\.\w+)/i,
];
/**
 * Extract filename from prompt
 */
function extractFilename(prompt) {
    const lowerPrompt = prompt.toLowerCase();
    // README detection
    if (lowerPrompt.includes('readme')) {
        return 'README.md';
    }
    // Generic file pattern matching
    for (const pattern of FILE_CREATION_PATTERNS) {
        const match = prompt.match(pattern);
        if (match && match[1]) {
            return match[1];
        }
    }
    return null;
}
/**
 * Generate default content based on filename
 */
function generateContent(filename, prompt) {
    const basename = path.basename(filename, path.extname(filename));
    const ext = path.extname(filename).toLowerCase();
    switch (ext) {
        case '.md':
            return `# ${basename}\n\nGenerated by deterministic executor.\n\nTask: ${prompt}\n`;
        case '.json':
            return JSON.stringify({ name: basename, generated: true }, null, 2);
        case '.txt':
            return `${basename}\n\nGenerated by deterministic executor.\nTask: ${prompt}\n`;
        case '.ts':
        case '.js':
            return `// ${basename}\n// Generated by deterministic executor\n\nexport const generated = true;\n`;
        default:
            return `Generated file: ${filename}\nTask: ${prompt}\n`;
    }
}
/**
 * DeterministicExecutor - For CLI_TEST_MODE=1
 *
 * Creates actual files on disk without spawning Claude Code CLI.
 * Performs proper filesBefore/filesAfter 2-scan per Property 31.
 */
class DeterministicExecutor {
    async isClaudeCodeAvailable() {
        // In deterministic mode, we don't need Claude Code CLI
        return true;
    }
    async execute(task) {
        const startTime = Date.now();
        const cwd = task.workingDir;
        // Step 1: filesBefore scan (Property 31)
        const filesBefore = await this.listFiles(cwd);
        // Step 2: Detect file creation from prompt
        const filename = extractFilename(task.prompt);
        // Step 3: Create file if detected
        const filesCreated = [];
        if (filename) {
            const fullPath = path.join(cwd, filename);
            const content = generateContent(filename, task.prompt);
            // Ensure parent directory exists
            const dir = path.dirname(fullPath);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
            // Write file
            fs.writeFileSync(fullPath, content, 'utf-8');
            filesCreated.push(filename);
        }
        // Step 4: filesAfter scan (Property 31)
        const filesAfter = await this.listFiles(cwd);
        // Step 5: Detect modified/created files via diff
        const files_modified = this.detectModifiedFiles(filesBefore, filesAfter, cwd);
        // Step 6: Build verified_files with actual disk verification
        const verified_files = [];
        const detectedAt = new Date().toISOString();
        // Verify all detected files
        for (const relPath of files_modified) {
            const fullPath = path.join(cwd, relPath);
            try {
                if (fs.existsSync(fullPath)) {
                    const stat = fs.statSync(fullPath);
                    let content_preview;
                    if (stat.size < 10000) {
                        try {
                            const content = fs.readFileSync(fullPath, 'utf-8');
                            content_preview = content.substring(0, 100);
                        }
                        catch {
                            // Binary or encoding issue
                        }
                    }
                    verified_files.push({
                        path: relPath,
                        exists: true,
                        size: stat.size,
                        content_preview,
                    });
                }
            }
            catch {
                // File access error - skip
            }
        }
        // Step 7: Determine status
        const hasVerifiedFiles = verified_files.some((vf) => vf.exists);
        let status = hasVerifiedFiles ? 'COMPLETE' : 'NO_EVIDENCE';
        // If no file creation was detected but prompt was processed, still mark as complete
        if (!filename && !hasVerifiedFiles) {
            // No file creation detected - informational response only
            status = 'COMPLETE';
        }
        const duration_ms = Date.now() - startTime;
        return {
            executed: true,
            output: filename
                ? `Created ${filename} successfully (deterministic mode)`
                : 'No file creation detected in prompt (deterministic mode)',
            files_modified,
            duration_ms,
            status,
            cwd,
            verified_files,
            unverified_files: [],
        };
    }
    /**
     * List all files in a directory (recursively)
     */
    async listFiles(dir) {
        const files = new Map();
        try {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                // Skip hidden files and node_modules
                if (entry.name.startsWith('.') || entry.name === 'node_modules') {
                    continue;
                }
                if (entry.isFile()) {
                    try {
                        const stat = fs.statSync(fullPath);
                        files.set(fullPath, {
                            mtime: stat.mtimeMs,
                            size: stat.size,
                        });
                    }
                    catch {
                        // File may have been deleted during scan
                    }
                }
                else if (entry.isDirectory()) {
                    const subFiles = await this.listFiles(fullPath);
                    for (const [key, value] of subFiles) {
                        files.set(key, value);
                    }
                }
            }
        }
        catch {
            // Directory may not exist or be inaccessible
        }
        return files;
    }
    /**
     * Detect files that were modified or created
     */
    detectModifiedFiles(before, after, baseDir) {
        const modified = [];
        for (const [filePath, afterStat] of after) {
            const beforeStat = before.get(filePath);
            // New file
            if (!beforeStat) {
                modified.push(path.relative(baseDir, filePath));
                continue;
            }
            // Modified file (mtime or size changed)
            if (beforeStat.mtime !== afterStat.mtime || beforeStat.size !== afterStat.size) {
                modified.push(path.relative(baseDir, filePath));
            }
        }
        return modified;
    }
}
exports.DeterministicExecutor = DeterministicExecutor;
/**
 * Check if deterministic mode is enabled
 */
function isDeterministicMode() {
    return process.env.CLI_TEST_MODE === '1';
}
/**
 * Create appropriate executor based on environment
 */
function createExecutorForEnvironment() {
    if (isDeterministicMode()) {
        return new DeterministicExecutor();
    }
    return null; // Let caller use default ClaudeCodeExecutor
}
//# sourceMappingURL=deterministic-executor.js.map