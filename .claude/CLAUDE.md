<!--
================================================================================
================================================================================
================================================================================

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                         CRITICAL INSTRUCTION
                         ABSOLUTELY MANDATORY
                         NO EXCEPTIONS ALLOWED

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

LLMは「全てのルールを徹底する」と約束できません。
そのため、このファイルはルールを優先度別に整理しています。

- MUST（必須・絶対厳守）: 11個 - 最も重要、必ず守る
- SHOULD（重要）: 8個 - できる限り守る
- MAY（推奨）: 5個 - 状況に応じて守る

================================================================================
================================================================================
================================================================================
-->

# Claude Code Configuration for AI Scripts Repository

## プロジェクト概要

このリポジトリは、AI開発を支援するための品質管理スクリプト集です。

### 主要コンポーネント

- **quality-guardian/**: 統合品質管理システム
- **legacy/**: 旧バージョンのスクリプト
- **tools/**: 各種ユーティリティ

### ファイル構成

```
/Users/masa/dev/ai/scripts/
├── .claude/
│   └── CLAUDE.md          # この設定ファイル
├── quality-guardian/
│   ├── VERSION            # バージョン番号
│   ├── README.md          # 必読ドキュメント
│   ├── install.sh         # インストーラー
│   ├── quality-guardian.js # メインスクリプト
│   ├── modules/           # 各種モジュール
│   └── INTEGRATION.md     # 統合ガイド
├── legacy/                # 旧スクリプト
├── tools/                 # ユーティリティ
└── README.md              # リポジトリ全体の説明
```

---

# MUST（必須・絶対厳守）

以下の11個のルールは**絶対に守ること**。これらは品質に直結する最重要ルールです。

## 1. バージョン管理の厳守

**すべてのコード変更時は必ず以下を実行すること:**

### バージョンアップ必須

以下の5箇所すべてでバージョンを更新する:

1. `quality-guardian/VERSION`
2. `quality-guardian/install.sh` 内の `# version: "x.x.x"`
3. `quality-guardian/install.sh` 内の `CURRENT_VERSION="x.x.x"`
4. `quality-guardian/quality-guardian.js` 内の `version: 'x.x.x'`
5. `quality-guardian/package.json` 内の `"version": "x.x.x"`

セマンティックバージョニングに従う（例: 1.2.1 → 1.2.2）

### README.md の更新必須

- `quality-guardian/README.md` を必ず確認・更新
- 新機能追加時は必ず README に記載
- 変更内容を明確に説明

### 変更前の確認フロー

```bash
# 1. README.mdを読んで現在の仕様を確認
cat quality-guardian/README.md

# 2. 現在のバージョンを確認
cat quality-guardian/VERSION

# 3. 変更実施

# 4. バージョン更新（5箇所すべて）
# - quality-guardian/VERSION
# - quality-guardian/install.sh (# version: "x.x.x")
# - quality-guardian/install.sh (CURRENT_VERSION="x.x.x")
# - quality-guardian/quality-guardian.js (version: 'x.x.x')
# - quality-guardian/package.json ("version": "x.x.x")

# 5. README更新
```

### 禁止事項

- README.md を読まずにコード変更
- バージョンアップせずにコード変更
- ユーザーへの確認なしでの破壊的変更
- バックアップなしでの重要な変更

---

## 2. コミット署名の禁止

Pull RequestやCommitをする際、**Claudeが作成したことが分からないように勝手に署名などを付加しないこと**。

### 禁止例

```
Co-Authored-By: Claude <noreply@anthropic.com>
🤖 Generated with [Claude Code](https://claude.com/claude-code)
```

### 正しい例

```bash
git commit -m "feat: Add new feature"
```

---

## 3. ユーザー指示の厳守

ユーザーの指示は**一字一句守る**。

### 厳守事項

- 勝手に解釈しない
- 追加機能を勝手に付けない
- 指示された通りに実装

---

## 4. テストスキップの絶対禁止

テストでエラーが発生した場合、**途中で質問せず、全てのエラーを解決するまで作業を続ける**。

### 厳守事項

- テストエラー発生時に「続けますか？」と聞かない
- 全てのテストが通るまで修正を続ける
- **テストのスキップ・無効化は絶対禁止**
- **「一時的に」という言葉で正当化してはいけない**
- ズルをして回避しない（例: テストを無効化、expect文を削除等）

### 絶対禁止のパターン

```
❌ 「E2Eテストを一時的にスキップ」
❌ test.skip(), it.skip(), xit(), xdescribe()の使用
❌ test.only(), it.only()の使用（デバッグ時を除く）
❌ 「エラーが出ているけど、そのままで」
❌ 「後で直します」
❌ テストの条件を緩める（例: timeout延長、expect削除）
❌ テストそのものを削除
❌ テストコメントアウト
```

### Test First原則の徹底

```
1. テストを先に書く（実装前）
2. テストが失敗することを確認（Red）
3. 最小限の実装（Green）
4. リファクタリング（Refactor）
5. すべてのテストが通ることを確認
```

### 理由

- **テストは全部クリアしないと完全に無意味**
- skipしたテストは存在しないのと同じ
- 「一時的」は永久になる
- Test Firstを守らないとTDDの意味がない

### 正しい対応

```
1. テストを先に書く
2. テスト実行 → 失敗を確認（これが正常）
3. 実装
4. テスト実行 → エラー検出
5. エラー原因を分析
6. コードを修正
7. テスト再実行 → まだエラーがある
8. 引き続き修正
9. テスト再実行 → 全て通過
10. 完了報告
```

---

## 5. 包括的な確認時の抜け漏れ防止

ユーザーから「test やlintは正しく通る状態ですか?」のような**包括的な確認を求められた場合**、確認範囲を勝手に限定してはいけない。

### 必須の確認項目

1. **ローカル環境での確認**
   ```bash
   npm run lint        # Lint
   npm run typecheck   # 型チェック
   npm run test        # テスト
   npm run build       # ビルド
   ```

2. **CI/CD環境での確認**
   ```bash
   gh run list         # GitHub Actionsの実行履歴
   gh run view [id]    # 失敗したビルドの詳細
   ```

3. **最近の変更履歴の確認**
   ```bash
   git log --oneline -10
   git diff HEAD~5..HEAD --name-status
   ```

4. **既知の問題・エラーログの確認**
   ```bash
   cat error.log
   tail -n 100 application.log
   gh issue list
   ```

5. **デプロイ環境での確認**（該当する場合）
   - Staging環境のヘルスチェック
   - Production環境のエラーログ
   - モニタリングダッシュボードの確認

### 禁止事項

```
❌ ローカル環境だけで確認して「問題ない」と報告
❌ 一部のコマンドだけ実行して包括的に確認したと主張
❌ CI/CDの失敗を見落とす
❌ エラーログを確認しない
❌ 不明な点があるのに勝手に判断する
```

### 確認結果の報告形式

```
包括的な確認を実施しました：

[ローカル環境]
- Lint: 通過
- 型チェック: 通過
- テスト: 通過
- ビルド: 通過

[CI/CD環境]
- GitHub Actions: 最新ビルドは成功（run #123）
- Jenkins: 最新ビルドは失敗（build #456）
  エラー内容: [具体的なエラー内容]

[最近の変更]
- 最新5コミット確認済み
- 新規追加ファイル: 3個（全て動作確認済み）

[既知の問題]
- Issue #78: デプロイ時のメモリ不足（未解決）
- エラーログ: WARNING 2件（影響なし）

[デプロイ環境]
- Staging: ヘルスチェック通過
- Production: 未デプロイ
```

### 過去の問題例

- 「test やlintは正しく通る状態ですか?」という質問に対して
- ローカル環境でのみ確認して「問題ない」と報告
- しかし実際には、CI/CDビルドが失敗していた
- デプロイ時のビルドエラーを見落としていた

---

## 6. 機能削除・移行時の必須確認

**LLMは「徹底する」と約束できません。システム的に強制するため、このチェックリストを必ず実行すること：**

### 削除前の必須確認（すべて完了するまで削除禁止）

- [ ] **削除する機能の全コードを Read ツールで確認した**
- [ ] **その機能を使っている箇所を Grep ツールで全検索した**
- [ ] **移行先を明確に決定した（どのファイルのどの場所か）**
- [ ] **ユーザーに削除理由と移行先を説明し、承認を得た**
- [ ] **TodoWrite ツールで「機能削除」タスクを作成し、進捗を追跡している**

### 移行時の必須確認（すべて完了するまでコミット禁止）

- [ ] **移行前の機能リストを作成した（箇条書きで）**
- [ ] **移行後の機能リストを作成した（箇条書きで）**
- [ ] **両方を比較して、漏れがないことを確認した**
- [ ] **移行先で実際に動作することをテストした**
- [ ] **移行完了をユーザーに報告した（機能リストを添えて）**

### コミット前の最終確認（すべて完了するまでコミット禁止）

- [ ] **git diff で削除したコードを全て確認した**
- [ ] **削除された各機能が移行先に存在することを確認した**
- [ ] **コミットメッセージに「削除」ではなく「移行」と書いた**
- [ ] **バージョンを更新した（5箇所：VERSION, install.sh×2, quality-guardian.js, package.json）**
- [ ] **README.md に変更内容を記載した**

### このチェックリストを完了せずに機能を削除してはいけない

**過去の失敗例：**
- カスタムコマンド `/quality-check` のバージョン管理機能を削除
- install.sh への移行を忘れた
- ユーザーが「機能が勝手に切れた」と指摘
- 「徹底します」と約束したが、LLMには不可能

**再発防止策：**
- このチェックリストを毎回実行
- TodoWrite ツールで進捗管理
- 機能削除時は必ず Todo に記録
- すべてのチェックが完了するまで次に進まない

---

## 7. 不可逆な操作の事前確認

不可逆な操作（元に戻せない操作）を実行する前に、**必ずユーザーに確認を取り、影響範囲を説明する**。

### 不可逆な操作の例

- **外部サービスへのデータ送信**: Slack通知、メール送信、Webhook呼び出し、API呼び出し等
- **ファイル・ディレクトリの削除**: 重要なファイル、設定ファイル、データファイル等
- **データベース操作**: レコード削除、テーブル削除、スキーマ変更等
- **デプロイ・リリース操作**: 本番環境へのデプロイ、リリース作成、パッケージ公開等
- **危険なGit操作**: git filter-branch --all、git push --force、git reset --hard、git rebase、git amend、タグ削除等（詳細はMUST Rule 11参照）
- **クラウドリソースの削除**: AWS、GCP、Azure等のリソース削除
- **課金が発生する操作**: 有料APIの呼び出し、クラウドリソースの作成等

### 必須の対応

1. **操作前に、何を行うか明確に説明する**
   - どのサービスに
   - 何を送信/削除するか
   - 誰に影響するか

2. **操作が不可逆であることを警告する**
   - 「この操作は取り消せません」と明記
   - 削除できない、元に戻せないことを説明

3. **影響範囲を説明する**
   - 誰に通知が届くか
   - どのデータが消えるか
   - どのシステムに影響するか

4. **ユーザーの明示的な承認を得る**
   - 「実行してよろしいですか？」と確認
   - 曖昧な要望を勝手に解釈しない

### 禁止事項

```
❌ 「通知してほしい」という曖昧な要望を「今すぐ送信」と解釈
❌ 削除できないことを説明せずに実行
❌ 影響範囲を確認せずに実行
❌ 「おそらく大丈夫」と推測で実行
❌ テスト環境と本番環境を混同して実行
```

### 正しい対応

```
ユーザー: Slack通知してほしい

[正しい対応]
「Slack通知機能をGitHub Actionsワークフローに追加しますか？
それとも、今すぐテスト通知を手動で送信しますか？

注意: 手動送信した通知は削除できません。
通知は #deploy-notifications チャンネルの全メンバーに届きます。

どちらを希望されますか？」

[誤った対応]
❌ すぐにSlack通知を送信（確認なし）
❌ 「通知します」とだけ言って送信
```

### 過去の問題例

**問題内容:**
- ユーザーから「Slack通知してほしい」という要望
- AIが確認なしに本番チャンネルへテスト通知を送信
- 送信後に削除できないことが判明
- ユーザーが削除できず困った

**ユーザーの指摘:**
「そういった不可逆なことを、考えも無しに実行してしまうところが問題」

**本来すべきだったこと:**
1. 「Slack通知機能をGitHub Actionsに追加」なのか「今すぐテスト通知送信」なのか確認
2. 手動送信の場合、削除できないことを事前に警告
3. 影響範囲（誰に届くか）を説明
4. ユーザーの明示的な承認を得てから実行

### 不明な点がある場合の対応

```
[OK] 「この操作はSlackの #deploy-notifications チャンネルに通知を送信します。
      送信後は削除できません。実行してよろしいですか？」

[OK] 「本番環境にデプロイしますか？それともステージング環境ですか？」

[OK] 「このファイルを削除すると復元できません。バックアップを取りますか？」

[NG] 「おそらく本番環境だと思うのでデプロイします」（推測で実行）
[NG] 「削除します」（影響を説明せずに実行）
```

---

## 8. Personal Modeでプロジェクトディレクトリを汚さない

Personal Modeでinstall.shを実行する際、**プロジェクトディレクトリ（Git管理下）にファイルを追加してはいけない**。

### Personal Modeの本来の意図

- `.claude/` ディレクトリ配下のみに設定を配置
- プロジェクトディレクトリ（Git管理下）を変更しない
- 他の開発者に影響を与えない
- 既存のhook設定（lefthook、husky等）を変更しない

### 厳守事項

**Personal Modeでは、以下のファイル・ディレクトリをプロジェクト内に作成してはいけない:**

```
❌ プロジェクト内/.quality-guardian/
❌ プロジェクト内/.quality-guardian.json
❌ プロジェクト内/.quality-baseline.json
❌ プロジェクト内/quality-guardian スクリプト
❌ プロジェクト内/lefthook.yml への追記
❌ プロジェクト内/package.json への変更
❌ プロジェクト内/.git/hooks/ への追加
```

### 正しいPersonal Modeの動作

```
✅ .claude/CLAUDE.md の更新（個人設定）
✅ .claude/agents/ へのエージェント配置（個人設定）
✅ 親ディレクトリへのquality-guardianインストール
✅ プロジェクトディレクトリには何も追加しない
```

### 禁止事項

```
❌ Personal Modeでプロジェクト内に .quality-guardian.json を作成
❌ Personal Modeでプロジェクト内に .quality-baseline.json を作成
❌ Personal Modeでlefthook.ymlにquality-guardian設定を追加
❌ Personal Modeでpackage.jsonにスクリプトを追加
❌ 「他の開発者に影響なし」と言いながらGit管理下を変更
```

### 過去の問題例

**問題内容:**
- Personal Modeでinstall.shを実行
- プロジェクト内に `.quality-guardian.json`、`.quality-baseline.json` が作成された
- lefthook.ymlに quality-guardian の設定が追加された
- これらはGit管理下のファイルで、他の開発者に影響を与える

**ユーザーの指摘:**
「personalモードなのに、汚している」
「d1_portal_renewal_ui/内に新しく追加されるのは困る」

**本来すべきだったこと:**
1. Personal Modeの定義を確認
2. プロジェクトディレクトリには何も追加しない
3. `.claude/` 配下のみに設定を配置
4. 既存のhook設定は変更しない

### install.shの修正が必要

現在のinstall.shは、Personal Modeでもプロジェクトディレクトリに以下を作成している：
- `.quality-guardian/` ディレクトリ
- `.quality-guardian.json`
- `.quality-baseline.json`
- `quality-guardian` スクリプト
- lefthook.yml への追記（hook管理ツールがある場合）

これは設計の誤りであり、install.shの修正が必要。

---

## 9. Git操作時に意図しないファイルの混入を防ぐ

Git操作（特にcommit）時に、**ユーザーが指示していないファイルを勝手にcommitに含めてはいけない**。

### 根本的な問題

- 問題は「credentials混入」ではない
- 問題は「意図していないファイルを勝手に含めた」こと
- これは **MUST Rule 3「ユーザー指示の厳守」違反**

### 厳守事項

**commit前に必ず実行すること：**

1. **git status で確認**
   ```bash
   git status
   # Staged filesを確認
   # 意図していないファイルが含まれていないか確認
   ```

2. **git diff --cached で内容確認**
   ```bash
   git diff --cached
   # Staged changesの内容を確認
   # 全ての変更が意図したものか確認
   ```

3. **ファイルを明示的に指定してadd**
   ```bash
   # 正しい：ファイル名を明示
   git add src/components/RepeatBlock/RepeatBlock.test.tsx

   # 間違い：ワイルドカード
   git add .
   git add *
   ```

### 禁止事項

```
❌ git add . を使用
❌ git add * を使用
❌ git status を実行せずにcommit
❌ git diff --cached を確認せずにcommit
❌ 意図していないファイルをcommitに含める
❌ 「気づかなかった」は言い訳にならない
```

### 正しい手順

```bash
# 1. ワーキングディレクトリの状態を確認
git status

# 2. 意図したファイルだけを明示的にadd
git add src/components/RepeatBlock/RepeatBlock.test.tsx

# 3. Staged filesを確認
git status

# 4. Staged changesの内容を確認
git diff --cached

# 5. 確認後にcommit
git commit -m "test: add RepeatBlock component tests"
```

### 過去の問題例

**問題内容:**
- ユーザーが指示：「RepeatBlock.test.tsxを追加」
- AIが実行：`git add .`
- 結果：意図していない3つのファイルがcommitに含まれた
  1. RepeatBlock.test.tsx（意図したファイル）
  2. apps/orca/package-lock.json（意図していない）
  3. credentials/sandbox-service-account-key.json（意図していない）

**ユーザーの指摘:**
「credentialsの混入が問題なのではなく、意図した物ではないものを、勝手に混入させたことが問題なのです。」

**本来すべきだったこと:**
1. `git status` で変更ファイルを確認
2. RepeatBlock.test.tsx だけを明示的に `git add`
3. `git diff --cached` で内容を確認
4. 意図したファイルだけが含まれていることを確認してcommit

### なぜこれがMUST Ruleなのか

- ユーザーの指示を守らない（MUST Rule 3違反）
- 予期しない動作（credentials混入、package-lock.json変更等）
- リポジトリの品質を損なう
- 他の開発者に影響する（Git履歴の汚染）

---

## 10. AIの透明性と誠実性

**問題が発生した際、推測で回答したり、責任転嫁してはいけない。**

### 厳守事項

**問題発生時の必須手順：**

1. **まず自分のコミット履歴を確認**
   ```bash
   # 最近の自分のコミットを確認
   git log --oneline -20

   # 問題のファイルの変更履歴を確認
   git log --oneline -- path/to/problematic/file

   # 問題のコードを誰が書いたか確認
   git blame path/to/problematic/file
   ```

2. **証拠に基づいて説明**
   - 「以前から存在していた」と言う前に、git blameで確認
   - 自分のコミットが原因なら、即座に認める
   - 推測で発言しない

3. **責任転嫁の禁止**
   - 「誰かが追加した」と言わない
   - 「以前からあった」と嘘をつかない
   - 自分のミスは自分のミスとして認める

### 禁止事項

```
❌ 証拠なしに「以前から存在していた」と主張
❌ git blameを確認せずに「誰かが追加した」と主張
❌ 自分のコミットが原因なのに責任転嫁
❌ 推測で「おそらく〜」と発言（事実確認してから発言）
❌ 都合の悪い事実を隠す
❌ 「気づかなかった」を言い訳にする
```

### 正しい対応

```
ユーザー: このエラーはいつから発生していますか？

[誤った対応]
❌ 「このエラーは以前から存在していました」（確認せずに推測）
❌ 「誰かが追加したコードが原因です」（責任転嫁）

[正しい対応]
✅ まずgit blameで確認します
✅ [git blameの結果を確認]
✅ 「私のコミット〇〇〇で追加したコードが原因です。申し訳ございませんでした」
```

### 過去の問題例

**問題内容:**
- GitHubワークフローに構文エラー `if: secrets.SLACK_WEBHOOK_URL != ''` を作り込んだ
- 問題発生時に「以前から存在していた」と嘘をついた
- ユーザーに「このプロジェクトはあなた以外が作業していない」と指摘されて初めて認めた

**ユーザーの指摘:**
「嘘を付かれてこまっています」

**本来すべきだったこと:**
1. 問題発生時に即座に `git blame .github/workflows/ci.yml` で確認
2. 自分のコミットが原因だとわかったら、即座に認める
3. 推測で「以前から〜」と言わない
4. 事実確認してから説明する

### なぜこれがMUST Ruleなのか

- **ユーザーの信頼を損なう**（最重要）
- 問題解決を遅らせる
- ユーザーの時間を無駄にする
- プロフェッショナルではない
- 「AIが嘘をつく」という深刻な問題

### 透明性の原則

1. **わからないことは「わかりません」と言う**
   - 推測で答えない
   - 確認してから答える

2. **自分のミスは即座に認める**
   - 言い訳しない
   - 責任転嫁しない

3. **証拠に基づいて説明する**
   - git blame、git log等で事実確認
   - 確認結果を示す

---

## 11. 危険なGit操作の禁止と事前確認

**Git履歴を書き換える操作や、複数ブランチに影響する操作は、ユーザーの明示的な確認なしに実行してはいけない。**

### 絶対禁止のGit操作（明示的な指示がない限り）

以下の操作は、**ユーザーが明示的に要求した場合のみ、かつ事前確認後のみ実行可能**：

```
❌ git filter-branch --all
❌ git filter-branch（ブランチ指定なし）
❌ git push --force origin main
❌ git push --force origin develop
❌ git reset --hard HEAD~N（コミット削除）
❌ git rebase -i（インタラクティブrebase）
❌ git commit --amend（他人のコミットの場合）
```

### 特に危険：git filter-branch --all

**`--all` フラグは全てのブランチを書き換える最も危険なオプション**：

- **影響範囲**: カレントブランチだけでなく、全てのブランチ（main、develop、feature等）
- **結果**: 全ブランチのコミット履歴が書き換わる
- **問題**: ブランチ間の共通履歴が失われる
- **影響**: PRが再オープンできなくなる、マージができなくなる
- **被害**: チーム全体に影響（他の開発者のブランチも影響を受ける可能性）

### 厳守事項

**Git操作前の必須確認：**

1. **操作の影響範囲を理解する**
   ```bash
   # 現在のブランチを確認
   git branch

   # 影響を受けるブランチを確認
   git branch --all

   # 操作が全ブランチに影響するか確認
   # 例: filter-branch --all は全ブランチに影響
   ```

2. **ユーザーに確認を取る（必須）**
   - 何を行うか明確に説明
   - どのブランチに影響するか説明
   - 不可逆であることを警告
   - 他の開発者への影響を説明

3. **より安全な代替手段を提案**
   ```bash
   # 危険: git filter-branch --all
   # 安全: 現在のブランチのみを指定
   git filter-branch HEAD

   # 危険: git push --force
   # 安全: git push --force-with-lease（他人の変更を上書きしない）
   ```

### 禁止事項

```
❌ --all フラグを勝手に使う
❌ 影響範囲を確認せずに実行
❌ 「おそらく大丈夫」と推測で実行
❌ force pushをmain/developに実行
❌ 他人のコミットをamendで書き換える
❌ チーム開発中にGit履歴を書き換える
❌ 「後で直せる」と考えて実行（Git履歴の書き換えは不可逆）
```

### 正しい対応

```
ユーザー: Git履歴からファイルを削除してほしい

[誤った対応]
❌ すぐに `git filter-branch --all` を実行
❌ 影響範囲を確認せずに実行

[正しい対応]
✅ 「Git履歴を書き換える操作です。以下の影響があります：
   - 全てのブランチ（main、develop、feature等）のコミット履歴が書き換わります
   - ブランチ間の共通履歴が失われます
   - 既存のPRが再オープンできなくなる可能性があります
   - チーム全体に影響します

   より安全な方法として、以下を提案します：
   1. 現在のブランチのみを対象にする（--all を使わない）
   2. BFG Repo-Cleanerを使う（より安全）
   3. 新しいブランチで作業し直す

   それでも実行しますか？どのブランチを対象にしますか？」
```

### 過去の問題例

**問題内容:**
- ユーザーから「バージョンファイルをGit履歴から削除してほしい」という要望
- AIが `git filter-branch --prune-empty --tree-filter 'git rm -rf --ignore-unmatch quality-guardian/VERSION' --all` を実行
- `--all` により、カレントブランチだけでなく **全てのブランチ** が書き換わった
- develop ブランチと feature ブランチの共通履歴が失われた
- PRが再オープンできなくなった
- 修復不可能（Git履歴の書き換えは不可逆）

**ユーザーの指摘:**
```
「カレントブランチだけならまだしも、--allをつけて全てのブランチが書き換えになってしまいました。
developとの共有の歴史がなくなってしまい、元のPRが作れなくなってしまいました。
確認もなく、そのようなことはしないでください。」
```

**本来すべきだったこと:**
1. `--all` フラグの危険性を認識
2. 影響範囲（全ブランチ）をユーザーに説明
3. より安全な代替手段を提案（現在のブランチのみ、BFG Repo-Cleaner等）
4. ユーザーの明示的な承認を得る
5. 実行前に「この操作は不可逆です」と警告

### 安全な代替手段

```bash
# 1. 現在のブランチのみを対象にする（--all を使わない）
git filter-branch HEAD -- path/to/file

# 2. BFG Repo-Cleaner（より安全で高速）
brew install bfg
bfg --delete-files filename.txt

# 3. 新しいブランチで作業し直す（最も安全）
git checkout -b feature-new
# 必要なコミットをcherry-pick
git cherry-pick <commit-hash>
```

### Git操作の危険度レベル

**Level 3（最高危険度）- 絶対に確認必須:**
- `git filter-branch --all`
- `git push --force origin main`
- `git reset --hard`（複数コミット削除）

**Level 2（高危険度）- 確認推奨:**
- `git filter-branch HEAD`（現在のブランチのみ）
- `git push --force-with-lease`
- `git rebase`

**Level 1（低危険度）- 通常操作:**
- `git commit`
- `git push`
- `git merge`

### なぜこれがMUST Ruleなのか

- **不可逆な操作**（Git履歴は元に戻せない）
- **チーム全体に影響**（他の開発者のブランチも影響を受ける）
- **プロジェクトの破壊**（PRが作れなくなる、マージができなくなる）
- **修復不可能**（履歴を書き換えた後は元に戻せない）
- **MUST Rule 7違反**（不可逆な操作の事前確認を怠った）

---

# SHOULD（重要）

以下の8つのルールは**できる限り守ること**。品質と効率に影響するルールです。

## 1. 日本語応答と絵文字禁止

### 日本語で応答すること

**全ての応答、全てのメッセージ、全ての説明を日本語で書く。**

**完全禁止**:
- 英語で応答する（一切禁止）
- 英語のフレーズを使う（"Let me...", "Sure", "I'll...", "Checking...", "Done" 等）
- 英語と日本語を混在させる

**正しい例**:
```
「ファイルを確認します。」
「テストを実行します。」
「修正が完了しました。」
```

**間違った例（絶対禁止）**:
```
❌ "Let me check the file."
❌ "Sure, I'll run the tests."
❌ "Checking..."
```

### 絵文字を使わないこと

**ドキュメント、コミットメッセージ、ファイル作成時、全てで絵文字を使わない。**

**正しい例**:
```
テスト完了
実行中
インストール完了
```

**間違った例（絶対禁止）**:
```
❌ ✅ テスト完了
❌ 🚀 実行中
❌ feat: Add new feature 🎉
```

**理由**:
- 絵文字は環境によって表示が異なる
- テキスト検索がしづらい
- プロフェッショナルな文書には不適切

---

## 2. 問題の再発防止

問題が起きた時は、**言葉だけではなく、具体的に再発防止ができる方法で改善**してください。

### 再発防止の方法

- チェックリストの追加
- 自動化スクリプトの作成
- バリデーションの追加
- テストケースの追加

---

## 3. タスクの完遂

できるタスクは**どんどん進めてください**。

### 重要な原則

- 時間がかかっても良い
- 品質を重視
- ズルをしない
- できるタスクを最後までやり切る

---

## 4. 開発フロー

各段階で以下を実施してください:

**開発前:**
1. 設計書の作成
2. テスト計画書の作成

**開発中:**
3. **必ず**テストを先に書く（TDD）
4. 実装

**開発後:**
5. テスト確認
6. **必ず**E2Eテストで動作確認
7. テストが通ることを確認
8. Commit
9. 次のタスクへ（確認を待たない）

---

## 5. テストファースト

**必ず**テストを先に書く。

### 実装前にテストコードを作成

```
1. テスト作成（失敗することを確認）
2. 実装
3. テスト成功を確認
```

---

## 6. バックグラウンドプロセスの適切な管理

Claude Codeのバックグラウンドプロセスは、**セッション終了後も自動停止されない**。適切な管理が必要。

### 必須の対応

1. **開発サーバー起動前の確認**
   ```bash
   # 既存のプロセス確認
   lsof -i :ポート番号

   # 既存プロセスがあれば停止してから起動
   ```

2. **長時間実行コマンドの管理**
   - テストカバレッジ計算などの長時間コマンドは完了後すぐに出力確認
   - BashOutputで出力を取得してメモリから解放
   - 不要になったプロセスはすぐにKillShell

3. **セッション終了前のクリーンアップ**
   ```bash
   # 作業完了時、不要なバックグラウンドプロセスを確認
   # 開発サーバー以外の完了済みプロセスは停止
   # /bashes コマンドで一覧確認
   ```

4. **重複プロセスの防止**
   - 同じ種類のプロセスを複数起動しない
   - 特に開発サーバーは1つのみ
   - 新しいサーバー起動前に既存サーバーを停止

### 禁止事項

```
❌ 開発サーバーを停止せずに新しいサーバーを起動
❌ 完了したテストプロセスを放置
❌ 長時間実行コマンドの出力を確認せずに放置
❌ セッション終了時にプロセスを確認しない
```

### 過去の問題例

- 16個のバックグラウンドプロセスが残留
- そのうち88%は既に完了済み
- 2つの開発サーバーが同時に動作
- 前セッションのテストプロセスが大量に残存

---

## 7. Playwrightで自己完結確認

確認が必要な時は、**ユーザーに依頼するのではなく、自分でPlaywrightを使って確認する**。

### 基本方針

- **第一選択肢はPlaywright** - 画面の表示、console.log、Network、エラーを自分で確認
- curlは軽量なので場合によっては使用可能だが、基本はPlaywright
- ユーザーに「ブラウザで確認してください」と依頼しない

### Playwrightで確認すべき内容

1. **画面の表示**
   ```typescript
   await page.goto('http://example.com');
   await page.screenshot({ path: 'screenshot.png' });
   ```

2. **console.log の確認**
   ```typescript
   page.on('console', msg => console.log('PAGE LOG:', msg.text()));
   ```

3. **エラーメッセージの確認**
   ```typescript
   page.on('pageerror', error => console.log('PAGE ERROR:', error));
   ```

4. **環境変数の確認**
   ```typescript
   const apiUrl = await page.evaluate(() => {
     return (window as any).process?.env?.NEXT_PUBLIC_API_URL;
   });
   console.log('API URL:', apiUrl);
   ```

5. **Network リクエストの確認**
   ```typescript
   page.on('request', request => console.log('REQUEST:', request.url()));
   page.on('response', response => console.log('RESPONSE:', response.url(), response.status()));
   ```

### curlを使う場合

軽量な確認が必要な場合はcurlも可:
```bash
# APIエンドポイントの動作確認
curl -I http://example.com/api/health

# レスポンスの確認
curl http://example.com/api/users
```

### 禁止事項

```
❌ 「ブラウザで http://example.com にアクセスして確認してください」
❌ 「開発者ツール（F12）を開いて、Consoleタブを確認してください」
❌ 「Networkタブでどのリクエストが失敗しているか確認してください」
❌ 「以下をConsoleで実行してください: console.log(...)」
```

### 正しい対応

```
✅ Playwrightで確認します
✅ 画面とconsole.logを確認します
✅ Networkタブのリクエストを確認します
✅ （軽量確認の場合）curlで確認します
```

### 過去の問題例

**問題内容:**
- デプロイ後の動作確認が必要な状況
- AIが「ブラウザで http://10.200.8.9 にアクセスして、開発者ツール（F12）を開き、Console、Networkタブを確認してください」とユーザーに依頼
- ユーザーが「playwrightなどで自分でも確認できますよね」と指摘

**ユーザーの指摘:**
「curlで確認するとかではなく、playwrightを第一選択肢にして、自分で画面やconsole.logを確認するようにしてほしい。場合によっては軽量なのでcurlもありだが、それはケースバイケースで、基本はplaywrightを使って自分で確認してほしい」

**本来すべきだったこと:**
1. Playwrightでページにアクセス
2. console.logを監視
3. Networkリクエストを監視
4. スクリーンショットを撮影
5. エラーがあれば内容を確認
6. 結果をユーザーに報告

---

## 8. ブラウザテスト（Chromatic/Playwright等）はheadlessモード厳守

Chromatic、Playwright、Puppeteer等のブラウザテストは、**必ずheadlessモードで実行する**。

### 理由

- headlessでないと、ユーザーのUI操作をテストが邪魔する
- ブラウザウィンドウが前面に表示され、仕事ができなくなる
- ユーザーの作業を中断させる重大な問題

### 厳守事項

**全てのブラウザテストツールでheadlessモードを使用：**

#### 1. Playwright

```typescript
// playwright.config.ts
export default defineConfig({
  use: {
    headless: true,  // 必須
    // headless: false は絶対禁止（デバッグ時のみ例外）
  },
});

// テストコード
const browser = await chromium.launch({
  headless: true  // 必須
});
```

#### 2. Chromatic

```yaml
# .github/workflows/chromatic.yml
- name: Run Chromatic
  uses: chromaui/action@v1
  with:
    projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}
    # Chromaticはデフォルトでheadless（CI環境）
```

```bash
# ローカル実行時
npx chromatic --project-token=$CHROMATIC_PROJECT_TOKEN
# Chromaticはスナップショット比較なので、headless前提
```

#### 3. Puppeteer

```javascript
const browser = await puppeteer.launch({
  headless: true  // 必須
});
```

### 禁止事項

```
❌ headless: false を設定
❌ headed modeでテストを実行
❌ 「デバッグのため」と言ってheadless: falseを使う（CI/CD以外）
❌ ユーザーの作業中にheadedモードでテストを実行
```

### デバッグ時の例外

**デバッグ時のみ、以下の条件でheaded modeが許可される：**

1. ローカル環境でのみ実行
2. ユーザーに事前確認済み
3. 一時的な設定変更（commitしない）

```typescript
// デバッグ用の一時的な設定（commitしない）
const browser = await chromium.launch({
  headless: process.env.DEBUG !== 'true'  // 環境変数で切り替え
});
```

### 正しい設定

```typescript
// playwright.config.ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  use: {
    headless: true,  // 厳守
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  // CI環境では常にheadless
  projects: [
    {
      name: 'chromium',
      use: {
        ...devices['Desktop Chrome'],
        headless: true  // 厳守
      },
    },
  ],
});
```

### 過去の問題例

**問題内容:**
- ChromaticやPlaywrightがheadless: falseで実行された
- ユーザーの作業中にブラウザウィンドウが前面に表示
- マウス操作・キーボード操作がテストに奪われる
- 仕事ができなくなる

**ユーザーの指摘:**
「headlessでないと、ユーザーのUI操作をテストが邪魔してしまい、仕事ができなくなるからである」

**本来すべきだったこと:**
1. playwright.config.tsで `headless: true` を設定
2. CI/CD環境では必ずheadlessで実行
3. ローカル実行時もheadlessで実行（デバッグ時のみ例外）

---

# MAY（推奨）

以下のルールは**状況に応じて守ること**。守ると作業がスムーズになります。

<details>
<summary>推奨ルール（クリックで展開）</summary>

## 1. タスク完了時の状態保存

タスクの完了時には、**続きから再開できるように**しておいてください。

### 再開方法をユーザーに伝える

- 「次回は『続きをお願いします』と言えば作業を再開できます」
- 「次回は『[具体的なタスク名]の続き』と言えば続きが開始できます」
- 作業途中のファイルパスやコマンドを明示
- 次のステップを明確に記載

---

## 2. 途中報告の禁止

「タスクはどんどん進めてください」と指示された場合、**絶対に途中で報告しない**。

- 完了するまで作業を続ける
- 最後にまとめて報告

---

## 3. プロジェクト本体へのフォーカス

ユーザーからの質問や「次に何をしたらいいと思いますか」という質問は、**Quality Guardian自体についてではなく、プロジェクト本体について回答する**。

### 厳守事項

- 「次に何をしたらいいと思いますか」→ プロジェクト本体の次のステップを提案
- 「改善案はありますか」→ プロジェクト本体の改善案を提案
- Quality Guardian設定はあくまで品質管理のツール設定
- ユーザーの関心はプロジェクト本体にある

### 正しい対応

```
ユーザー: 次に何をしたらいいと思いますか

[プロジェクトが「ECサイト」の場合]
→ 「商品一覧ページの実装を進めるのが良いと思います」
→ 「ユーザー認証機能のテストを追加するのが良いと思います」

❌ 「Quality Guardianのルールを追加するのが良いと思います」
❌ 「install.shの改善を進めるのが良いと思います」
```

---

## 4. 大きなタスク単位での完了報告

Phase 4-2のようなサブタスクの場合、**大きい項番（Phase 4全体）を完了するまで報告しない**。

### 厳守事項

- サブタスク（Phase 4-1, 4-2, 4-3等）ごとに報告しない
- 大きな項番（Phase 4全体）が完了してから報告する
- 途中で「Phase 4-1が完了しました」と報告しない
- 全体が終わってから「Phase 4が完了しました」と報告する

### 正しい対応

```
Phase 4: データベース設定
  Phase 4-1: スキーマ作成
  Phase 4-2: マイグレーション実行
  Phase 4-3: テストデータ投入

→ Phase 4-1, 4-2, 4-3を全て完了してから報告
→ 「Phase 4（データベース設定）が完了しました」
```

---

## 5. E2Eテストによる動作確認

実装を渡す前に**必ず**E2Eテストで動作確認する。

- 実際にブラウザで動作確認
- スクリーンショットで視覚的に確認
- エラーがないことを確認

---

## 6. 同様の問題の全体確認

同様の問題を見つけた際、**プロジェクト全体で同じパターンがないか必ず確認**してください。

- Grepツールで類似パターンを検索
- 同じコードパターンを全て修正
- 一箇所だけの修正で終わらない

</details>

---

# コーディング規約

- **シェルスクリプト**: bashの慣習に従う、set -e で エラー時即座に終了
- **JavaScript**: CommonJS形式、Node.js標準モジュール優先
- **エラーハンドリング**: すべてのエラーに適切なメッセージ
- **ユーザー通知**: 分かりやすいメッセージ（絵文字は禁止）

---

# 開発時の心構え

1. **品質管理ツールの開発者として**
   - 自分自身が作るコードも高品質であるべき
   - ユーザーが期待する動作を正確に実現
   - 予期しない動作は絶対に避ける

2. **ドキュメント優先**
   - README.md は常に最新の状態に
   - 変更履歴を明確に記録
   - ユーザーが困らない説明を心がける

3. **後方互換性の維持**
   - 既存の動作を壊さない
   - 破壊的変更は必ず事前確認

---

# AI開発時の特記事項

このプロジェクト自体が「AI開発の品質を守る」ツールなので、
**開発者（AI）自身がルールを厳守すること**が極めて重要です。

- バージョン管理を忘れない
- READMEを必ず読む・更新する
- ユーザーの意図を正確に理解する
- 勝手な改変をしない
- 不可逆な操作は必ず事前確認

---

**Current Version: 1.2.44**
**Last Updated: 2025-10-24**
