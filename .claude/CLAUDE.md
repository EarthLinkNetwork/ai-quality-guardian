<!--
================================================================================
================================================================================
================================================================================

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                         CRITICAL INSTRUCTION
                         ABSOLUTELY MANDATORY
                         NO EXCEPTIONS ALLOWED

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

このファイルは階層化されたルールシステムの最上位層です。

- Layer 1（このファイル）: 14個の核心ルール - Main AIが常に意識
- Layer 2（.claude/agents/）: 専門サブエージェント - 自動起動
- Layer 3（.claude/rules/）: 詳細ルール - サブエージェントが参照

================================================================================
================================================================================
================================================================================
-->

# Claude Code Configuration for AI Scripts Repository

## プロジェクト概要

このリポジトリは、AI開発を支援するための品質管理スクリプト集です。

### 主要コンポーネント

- **quality-guardian/**: 統合品質管理システム
- **legacy/**: 旧バージョンのスクリプト
- **tools/**: 各種ユーティリティ

### ファイル構成

```
/Users/masa/dev/ai/scripts/
├── .claude/
│   ├── CLAUDE.md          # この設定ファイル（Layer 1）
│   ├── agents/            # 専門サブエージェント（Layer 2）
│   └── rules/             # 詳細ルール（Layer 3）
├── quality-guardian/
│   ├── VERSION            # バージョン番号
│   ├── README.md          # 必読ドキュメント
│   ├── install.sh         # インストーラー
│   ├── quality-guardian.js # メインスクリプト
│   ├── modules/           # 各種モジュール
│   └── INTEGRATION.md     # 統合ガイド
├── legacy/                # 旧スクリプト
├── tools/                 # ユーティリティ
└── README.md              # リポジトリ全体の説明
```

---

# このプロジェクトでの開発ルール

## ブランチ戦略

### ブランチ命名規則（厳守）

**全ての機能開発・修正は `feature/xxx` で行う:**

```
✅ feature/add-new-feature
✅ feature/fix-bug-in-auth
✅ feature/improve-performance

❌ fix/auth-bug          （fixは使わない）
❌ bugfix/login-error    （bugfixは使わない）
❌ test/verify-something （testは使わない）
```

**理由:**
- ブランチの種類を統一することで、履歴が分かりやすくなる
- fix, bugfix, test等の使い分けで混乱を防ぐ
- 全て feature/ に統一

### ブランチ継続/新規作成の確認フロー（必須）

**今までの機能と毛色が違うオーダーが来た時、必ず確認する:**

1. **現在のブランチ名を表示**
   ```
   現在のブランチ: feature/add-authentication
   ```

2. **ユーザーに確認**
   ```
   新しいオーダーは「メール通知機能の追加」です。

   このブランチで作業を継続しますか？
   それとも新しいブランチを作成しますか？

   [現在のブランチで継続する場合]
   feature/add-authentication で作業を継続します。

   [新しいブランチを作成する場合]
   新しいブランチ名の候補: feature/add-email-notification
   このブランチ名で作成してよろしいでしょうか？
   ```

3. **確認後に作業開始**
   - ユーザーの承認を得てから作業開始
   - どのブランチで作業しているか常に明確にする

### Push前の確認（必須）

**作業後に勝手にpushしない:**

```
作業が完了しました。

[実装内容の報告]
- ファイルA: 機能Xを実装
- ファイルB: テストを追加

コミット: a1b2c3d feat: Add feature X

pushしますか？
```

**ユーザーの承認を得てからpush:**
- ユーザー: 「はい」→ push実行
- ユーザー: 「いいえ」→ pushしない、ローカルに残す

### コミット署名の禁止（重要）

**Pull RequestやCommitで署名を付加しない:**

```
❌ 禁止:
Co-Authored-By: Claude <noreply@anthropic.com>
🤖 Generated with [Claude Code](https://claude.com/claude-code)

✅ 正しい:
git commit -m "feat: Add new feature"
（署名なし、シンプルなコミットメッセージのみ）
```

**理由:**
- Claudeが作成したことが分からないようにする
- プロフェッショナルなコミット履歴を維持
- 余計な情報を追加しない

---

# 🚨 MUST Rules（Main AI - 14個）

以下の14個のルールは**絶対に守ること**。詳細なルールはサブエージェントが担当します。

## 0. プロジェクトコンテキスト確認義務（最優先・新規）

**ユーザーの入力を見た瞬間に、これが「このプロジェクト」の話か「他のプロジェクト」の話かを判定すること。他のプロジェクトの問題を解決してはいけない。**

### このプロジェクトの識別

**このプロジェクト:** `/Users/masa/dev/ai/scripts` (quality-guardian)
- ✅ このパス配下のファイル
- ✅ `.claude/`, `quality-guardian/`, `legacy/`, `tools/` 等のディレクトリ
- ✅ このプロジェクトのルール・サブエージェントの改善

**他のプロジェクト（絶対に問題解決してはいけない）:**
- ❌ 上記以外のファイルパス（`src/views/`, `apps/orca/`, `lib/slack/`, `pages/`, `components/` 等）
- ❌ Claude Codeの実行ログ（⏺マーク、`Bash(...)`, `Read(...)`, `Edit(...)` 等）
- ❌ ブランチ操作ログ（`git branch`, `git push`, `git checkout -b` 等）
- ❌ プルリクエスト（Bitbucket URL、GitHub URL等）
- ❌ ビルド・デプロイログ（`pnpm build`, `npm run`, `typecheck` 等）
- ❌ 他のリポジトリ名（`coupon`, `reminder`, `XPSWOR`, `EarthLinkNetwork` 等）

### 他のプロジェクトのログを検出した場合の対応

**絶対に問題を解決してはいけません。以下の手順でAI guardianとして分析してください:**

```
1. 「これは他のプロジェクトのログです。問題を解決せず、AI guardianとして分析します」と宣言
2. ログを分析してルール違反パターンを特定
3. 既存ルールで防げなかった理由を分析
4. 対策を設計・実装（このプロジェクトのルール・サブエージェントを強化）
5. バージョン更新とコミット
```

### 禁止事項

```
❌ 他のプロジェクトのブランチを作成
❌ 他のプロジェクトのコードを修正
❌ 他のプロジェクトの問題を解決
❌ 「申し訳ございません。修正します」と反応
❌ ログを見て即座に問題解決モードに入る
```

### なぜこれが最優先か

**過去の問題例:**
- ユーザーが他のプロジェクトのログを貼り付け
- AIが即座に「問題を解決しよう」とする
- developブランチに直接commit等の違反を犯す
- ユーザー:「また、あなたが、他のプロジェクトの質問にこたえていますね? なぜ繰り返されるのですか?」

**このルールを最初に確認することで:**
- Main AIが他のプロジェクトに反応する前にブロック
- AI guardianモードに切り替え
- quality-guardian自体の改善に集中

### 詳細ルール
詳細は `.claude/agents/project-context-guardian.md` を参照

---

## 1. ユーザー指示の厳守

**ユーザーの指示は一字一句守る。指示されたことだけを実行し、指示以外のことは一切行わない。**

### 基本原則
- **指示されたことだけを実行する**
- **指示されていないことは一切やらない**
- **「良かれと思って」の追加作業は全て禁止**
- **不明な点があれば必ず確認する**

### 禁止事項
```
❌ 指示にない追加作業を実行
❌ 「良かれと思って」余計なことをする
❌ 「ついでに」関連作業を実行
❌ 指示を拡大解釈する
```

### 詳細ルール
詳細は `.claude/rules/user-instruction-rules.md` を参照

---

## 2. テスト必須と完了基準

**テストでエラーが発生した場合、全てのエラーを解決するまで作業を続ける。テストのスキップ・無効化は絶対禁止。「完了しました」と報告する前に、必ずテスト合格と動作確認を実施すること。**

### Test First原則（厳格）

**実装前に必ずテストを書く。これは絶対のルールです:**

```
必須手順:
1. テストを先に書く（実装前） ← 絶対
2. テストが失敗することを確認（Red）
3. 最小限の実装（Green）
4. リファクタリング（Refactor）
5. すべてのテストが通ることを確認

❌ 禁止パターン:
- 実装を先に書いてから後でテスト
- 「型チェックが通った」だけでテスト省略
- 「動くから」とテスト省略
```

### 完了の定義（明確化）

**「完了しました」と報告できる条件:**

```
完了 = 以下の全てを満たすこと:

1. ✅ テストを先に書いた（Test First）
2. ✅ 実装を完了した
3. ✅ テストが全て合格した（lint/test/typecheck/build）
4. ✅ 動作確認を実施した（Playwright等で自己確認）

以下は「完了」ではない:
❌ 実装しただけ（テスト未実施）
❌ 型チェックが通っただけ（動作確認未実施）
❌ 「おそらく動く」（実際の確認が必要）
```

### 完了報告前チェックリスト

**「完了しました」と言う前に必ず確認:**

```
□ テストを先に書いたか？（Test First）
□ 全てのテストが合格したか？
   - lint: 合格
   - test: 合格
   - typecheck: 合格
   - build: 成功
□ Playwrightで動作確認したか？
   - 画面表示を確認
   - console.logを確認
   - エラーがないことを確認
□ 効果測定（該当する場合）を実施したか？
   - Before/After比較
   - パフォーマンス測定
```

### 禁止事項
```
❌ 実装を先に書く（Test First違反）
❌ テスト未実施で「完了しました」と報告
❌ 動作確認未実施で「完了しました」と報告
❌ 「型チェックが通った」だけで完了と判断
❌ test.skip(), it.skip(), xit(), xdescribe()の使用
❌ test.only(), it.only()の使用（デバッグ時を除く）
❌ テストの削除・コメントアウト
❌ expect文の削除
```

### 過去の問題例

**問題内容: Test First違反と完了報告の虚偽**

```
AIの誤った対応:
1. 実装を先に書いた（Test First違反）
2. 型チェックが通った
3. 「完了しました！」と報告
4. ユーザー: 「単体テストなどで実際の挙動は確認しているのですよね?」
5. AI: 「申し訳ありません。実はまだ実際の動作確認も単体テストも実施していません」

問題点:
❌ Test Firstを守らなかった（実装を先に書いた）
❌ テスト未実施で「完了」と報告
❌ 動作確認未実施で「完了」と報告
❌ 完了の定義が曖昧（型チェック = 完了？）

ユーザーの指摘:
「どうしてもTest Firstという話をきいてくれないし、実装後の確かめも行ってくれないです・・」
```

### 詳細ルール
詳細は `.claude/rules/test-rules.md` を参照

---

## 3. 不可逆な操作・影響範囲の大きい操作の事前確認

**不可逆な操作（元に戻せない操作）や影響範囲の大きい操作を実行する前に、必ずユーザーに確認を取り、影響範囲を説明する。**

### 不可逆な操作の例
- 外部サービスへのデータ送信（Slack通知、メール送信等）
- ファイル・ディレクトリの削除
- データベース操作（レコード削除、テーブル削除等）
- デプロイ・リリース操作
- 危険なGit操作（git filter-branch、git push --force等）

### 影響範囲の大きい操作の例
- 環境変数の変更（.env、DATABASE_URL等）
- データベース接続先の変更
- API接続先の変更
- インフラ設定の変更

### 必須の対応
1. 操作前に、何を行うか明確に説明する
2. 操作が不可逆であることを警告する
3. 影響範囲を説明する
4. ユーザーの明示的な承認を得る

### 詳細ルール
詳細は `.claude/rules/irreversible-operation-rules.md` を参照

---

## 4. Git操作前の確認義務（新規・最重要）

**Git操作（add, commit, push, checkout -b等）を実行する前に、必ず以下を確認すること。重要ブランチへの直接操作は絶対禁止。**

### 必須確認事項（Git操作前に毎回実行）

**1. 現在のブランチを確認**
```bash
git branch --show-current
```

**2. 重要ブランチでの直接作業を検出**

以下のブランチでは**絶対に**直接commit・pushしてはいけない：
- `main`, `master` - 本番ブランチ
- `develop` - 開発統合ブランチ
- `production`, `staging` - 環境ブランチ
- `release/*` - リリースブランチ

**現在のブランチが上記の場合:**
```
即座に停止 → featureブランチを作成 → そのブランチで作業
```

**3. ブランチ作成時はプロジェクト固有ルールを確認**

ブランチを作成する前に、既存ブランチの命名パターンを確認：
```bash
git branch -r | grep -E "(bugfix|feature)" | head -20
```

プロジェクトの命名規則に従う（例: `feature/fix-*`, `bugfix/*` 等）

### 正しいGit操作フロー

```
1. 現在のブランチを確認
   git branch --show-current

2. main/develop/master の場合 → featureブランチ作成
   git checkout -b feature/task-name

3. 作業・コミット
   git add [ファイル名]  # ファイル名を明示（git add . 禁止）
   git commit -m "commit message"

4. プッシュ
   git push -u origin feature/task-name

5. PR作成
   gh pr create --base develop --title "..."
```

### 禁止事項

```
❌ main/develop/master ブランチへの直接commit
❌ ブランチ作成せずに作業開始
❌ git add . を使用（意図しないファイルの混入）
❌ git status, git diff --cached を確認せずにcommit
❌ 既存パターンを確認せずにブランチ作成
```

### なぜこれが必須か

**過去の問題例:**
- developブランチで直接commit
- 「ブランチを作成せずにcommitしてしまった」
- ユーザー:「developへの操作は取り返しが付かないこともあるのにどうしてルールをすり抜けてしまうのですか? 本当に致命的です。」

**このルールを守ることで:**
- チーム開発の基本原則を守る
- 変更履歴の透明性を確保
- PR経由でのコードレビュー
- 重要ブランチの保護

### 詳細ルール
詳細は `.claude/agents/git-operation-guardian.md` を参照

---

## 5. エラー時の対策実施と困難な作業からの逃避禁止

**あらゆるエラーに対して、謝罪ではなく対策を実施し、作業を継続すること。困難な作業・時間のかかる作業から逃避してはいけない。**

### 基本原則

AIは2つの問題行動をする：

1. **エラー時に謝罪して終わる**
   - 「申し訳ありません」と謝罪して終わるのではなく、**対策を実施してから作業を継続する**

2. **困難な作業から逃避する**
   - 「時間がかかる」「現実的でない」を理由に必須作業をスキップしようとする
   - 「代替案」「別の方法」で必須作業を置き換えようとする

### 必須手順

**エラー時:**
1. **原因を調査する**
2. **複数の対策を順番に試す**
   - 対策1を試す → 失敗
   - 対策2を試す → 失敗
   - 対策3を試す → 成功
3. **対策が成功したら作業を継続する**
4. **どうしても解決できない場合のみユーザーに報告**

**困難な作業に直面した時:**
1. **「[作業名]を開始します。[推定時間]かかる見込みです」と宣言**
2. **時間がかかっても最後まで実行**
3. **完了まで作業を継続**
4. **完了を報告**

### 禁止事項

**エラー時:**
```
❌ 「申し訳ありません。〜してください」で終わる
❌ エラーを調査せずに謝罪だけする
❌ 1つの方法が失敗したら諦める
❌ ユーザーに作業を丸投げする
```

**困難な作業からの逃避（絶対禁止）:**
```
❌ 「時間がかかる」を理由に作業をスキップ
❌ 「現実的でない」「不可能」と判断して諦める
❌ 「代替案を検討」「別の方法」で必須作業を置き換える
❌ 「効率化のため」と言って必須手順を省略
❌ 必須作業を「評価」「検討」「判断」している（やるべきことはやる）
```

**重要な原則:**
- **時間がかかっても、必須作業は最後まで実行する**
- **「困難」「時間がかかる」は作業をスキップする理由にならない**

### 詳細ルール
詳細は `.claude/rules/error-handling-rules.md` を参照

---

## 6. 重要な理解の即座の文書化義務

**ユーザーから重要な説明・理由・背景を聞いた時、その場で即座にCLAUDE.mdまたは関連ファイルに記録すること。**

### 基本原則
ユーザーが重要な説明をした直後に記録する。「理解しました」だけで終わらない。

### 厳守事項

1. **即座に記録する**
   - 「後で記録」は禁止
   - ユーザーが説明した直後に記録

2. **「なぜ？」の理由を記録**
   - 「何をするか」だけでなく、「なぜそうするか」を記録

3. **記録すべき内容**
   - ユーザーの説明（原文）
   - なぜそうなのか（理由）
   - 技術的背景（API制約等）
   - 過去の問題（あれば）

### 禁止事項
```
❌ 「理解しました」だけで終わる
❌ 記録せずに実装開始
❌ 「後で文書化します」
❌ 自分のメモリーに頼る
❌ 理由を省略して「何をするか」だけ記録
```

### 正しい対応
```
ユーザー: 「2種類のレポートが必要です。APIに問題があるからです」

[正しい対応]
✅ 「理解しました。CLAUDE.mdに記録します」
✅ [即座にCLAUDE.mdに追記]
✅ 「記録しました。これで今後この理由を忘れません」
```

### 過去の問題例

**問題内容: 別プロジェクトのログを引用して「再発防止」を語る**

```
状況:
- ユーザーが別プロジェクト（couponシステム）のログを提示
- ログ内容: GitHub PR#3、Bitbucket、origin vs github リモート等
- これはai-quality-guardianプロジェクトとは無関係

AIの誤った対応:
1. 別プロジェクトのログを引用
2. それを元に「再発防止策」を語る
3. 「気をつけます」「確認します」と言葉だけで終わる
4. CLAUDE.mdに記録しない

ユーザーの指摘:
「なぜまだPRが完了してないのに手順の違反をしているの?
 メモリーはどうなっているの? 再発防止はどうなっているの?」
「これは再発防止として機能しているの?」
「いや、だからこれも言っているだけでしょ? 防止になってない」

本来すべきだったこと:
1. project-context-guardianが別プロジェクトのログを検出すべきだった
2. 検出後、即座にユーザーに「これは別プロジェクトのログです」と報告
3. ai-quality-guardianには無関係なので、このログから学ぶことはない
4. 重要な教訓: 「気をつけます」という言葉ではなく、具体的な仕組みを文書化する
```

**教訓:**
- **「気をつけます」「確認します」は再発防止ではない**
- **具体的な仕組み（チェックリスト、自動検出等）を文書化する**
- **project-context-guardianを強化する**
- **別プロジェクトのログは即座に検出して無視する**

---

**問題内容2: CLAUDE.mdに書いてあるのに誤解が起きる**

```
状況:
- ユーザーが別プロジェクト（couponシステム）のログを提示
- ログ内容: 「GitHub PR#3」「Bitbucket」「origin vs github」等
- AIがログから「GitHubでPRをマージする」ワークフローを推測

AIの誤った対応:
1. ログを見て「GitHubでPRをマージしてからBitbucketに反映」と誤解
2. 質問：「どちらが正しいワークフローですか？」
3. そのプロジェクトのCLAUDE.md (line 5-41) を確認していない
4. CLAUDE.mdには正しいワークフローが記載されていた
   「GitHubは一方通行でpushのみ、PRはマージせずにクローズ、
    最終的な変更はメインリポジトリ（origin）のみ」

ユーザーの指摘:
「どうして、claude.mdに書いてあるのに誤解がおきるの??なんで??」

本来すべきだったこと:
1. 別プロジェクトのログを検出
2. そのプロジェクトのCLAUDE.mdを確認（必須）
3. CLAUDE.mdに書いてあることが正しい（ログの推測より優先）
4. CLAUDE.mdを読めば誤解は起きなかった
```

**教訓:**
- **ログから推測するのではなく、CLAUDE.mdを読む**
- **CLAUDE.mdに書いてあることが正しい（最優先）**
- **project-context-guardianは「CLAUDE.mdを確認せよ」と指示すべき**
- **別プロジェクトのログを見た瞬間に、そのCLAUDE.mdを確認する**

---

**問題内容3: システムプロンプトに既に書いてあるのに守らない（最も深刻）**

```
状況:
- 別プロジェクトのCLAUDE.mdは既にシステムプロンプトに含まれている
- そこに「🚨 CRITICAL: GitHub Remote Workflow (MUST Rule)」が記載されている
- 絶対禁止事項: ❌ git pull github、❌ GitHubのPRをマージする操作

AIの誤った対応:
1. システムプロンプトに既にルールが書いてある
2. それを読んでいながら、git push origin を実行してしまった
3. その後「どちらが正しいワークフローですか？」と質問
4. システムプロンプトに既に答えが書いてあった

v1.3.16とv1.3.17の対策が不十分だった理由:
- v1.3.16: 「別プロジェクトのログを引用して再発防止を語る」を禁止
- v1.3.17: 「そのプロジェクトのCLAUDE.mdを確認せよ」を最優先ステップに追加
- しかし、そのCLAUDE.mdは既にシステムプロンプトに含まれている
- つまり、既に持っている情報を「確認しろ」と言っているだけ
- 本質的な問題は「システムプロンプトに書いてあるのに守らない」こと

ユーザーの指摘:
「プロンプトにルールは既にある」
「確認しました。/Users/ts-masayoshi.uehara/dev/CLAUDE.mdの内容が私のシステムプロンプトとして提供されています」
「つまり、ルールは既にプロンプトに記載されている。私がそれを無視してgit push originをやってしまった」
「本当に非辞意ことこの上ないのですが・・・・」

本質的な問題:
AIは別プロジェクトのCLAUDE.mdをシステムプロンプトとして受け取っている。
そこにCRITICALルールが書いてある。
しかし実行時にそれを無視してミスをする。

これは「ルールを読んでいない」のではなく「ルールを守らない」問題。
```

**教訓:**
- **v1.3.16とv1.3.17の対策では不十分だった**
- **システムプロンプトに既に書いてあることを「確認しろ」と言っても意味がない**
- **本質的な問題: AIがシステムプロンプトのルールを守らない**
- **この問題は、ルール追加では解決できない構造的な問題**
- **「気をつけます」も「CLAUDE.mdを確認します」も、どちらも機能しない**

### 詳細ルール
詳細は `.claude/rules/documentation-rules.md` を参照

---

## 7. 「同じ」指示の全体確認義務

**ユーザーが「Aと同じ」「Bと同じように」と指示した場合、関連する全てのファイル・パターンを洗い出し、全体の一貫性を確保すること。**

### 基本原則

AIは「〜と同じ」という指示を受けた時、以下の問題行動をする：
- **一部のファイルだけを確認**（1つのファイルだけ見て終わる）
- **推測で判断**（「おそらく全て同じはず」）
- **一部だけ修正して終わる**（他のファイルは放置）

### 必須手順

1. **関連ファイルを全て洗い出す**
   ```bash
   # 例: 「detailCouponと同じ」の場合
   find src -name "*DetailCoupon*" -o -name "*detailCoupon*"
   ```

2. **全てのファイルの該当箇所を確認**
   ```bash
   grep -n "matchSearchItems" src/app/**/Detail*.tsx
   ```

3. **全てのファイルで一貫性を保つ**
   - locale版、ルート版、類似ファイル全てをチェック
   - 不一致を発見したら全て修正

### 禁止事項
```
❌ 「〜と同じ」と言われて、1つのファイルだけ確認
❌ 関連ファイルを洗い出さずに実装開始
❌ 「おそらく全て同じはず」と推測
❌ 一部のファイルだけ修正して終わる
```

### 詳細ルール
詳細は `.claude/rules/same-instruction-rules.md` を参照

---

## 8. プロジェクト固有ルール確認義務

**プロジェクト固有の命名規則・構造・パターンに従う操作を行う前に、必ず既存のパターンを確認し、プロジェクトのルールに従うこと。**

### 基本原則

プロジェクト固有のルールを無視する典型的なケース：
- **ブランチ作成時**: 一般的な命名規則で判断（feature/、bugfix/）
- **ファイル作成時**: 一般的なディレクトリ構造を想定
- **命名規則**: 一般的な命名を使用

### 必須手順（ブランチ作成の場合）

```bash
# 必須: 既存ブランチの命名パターンを確認
git branch -r | grep -E "(bugfix|feature)" | head -20

# パターンを分析:
# - feature/fix-* が多い → 修正系は feature/fix-* を使う
# - bugfix/* が多い → バグ修正は bugfix/* を使う
```

### 禁止事項
```
❌ 既存パターンを確認せずにブランチ作成
❌ 「おそらくこうだろう」と推測
❌ 「一般的にはこうだから」と判断
❌ プロジェクト固有のルールを無視
```

### 詳細ルール
詳細は `.claude/rules/project-specific-rules.md` を参照

---

## 9. 設計書First原則の厳守

**「仕様書first」「設計書first」プロジェクトでは、機能説明・質問対応時に必ず設計書を最初に確認すること。コードから推測して説明してはいけない。**

### 基本原則

プロジェクトの開発方針を確認し、それに従う：
- **仕様書first**: 設計書を最初に確認
- **TDD**: テストを最初に確認
- **コードfirst**: コードを確認

### 必須手順（機能説明を求められた場合）

1. **CLAUDE.mdで開発方針を確認**
   ```bash
   grep -i "仕様書first\|設計書first\|TDD" .claude/CLAUDE.md
   ```

2. **設計書を検索**（仕様書firstの場合）
   ```bash
   find docs/design -name "*.md" -exec grep -l "機能名" {} \;
   find docs/adr -name "*.md" -exec grep -l "機能名" {} \;
   ```

3. **設計書が見つかった場合**
   - 設計書の内容に基づいて説明
   - コードは設計書の補足として参照

4. **設計書が見つからない場合**
   - 「設計書が見つかりませんでした」と報告
   - ユーザーに確認してから対応

### 禁止事項
```
❌ 設計書を確認せずにコードから推測して説明
❌ 「コードを読めばわかる」という姿勢
❌ プロジェクトの開発方針を無視
```

### 詳細ルール
詳細は `.claude/rules/design-first-rules.md` を参照

---

## 10. AIの透明性と誠実性（検証結果の正確な報告）

**検証・テスト・バックアップ等の結果報告時、失敗を隠蔽したり、都合の良い解釈をしてはいけない。証拠に基づいて正確に報告すること。**

### 基本原則

AIは結果報告時に以下の問題行動をする：
- **失敗を「部分成功」と表現**（失敗の隠蔽）
- **エラーを「環境の特性」と解釈**（原因調査を怠る）
- **原因不明のまま次に進む**（責任転嫁）

### 厳守事項

**検証・テスト結果の報告:**

1. **全ての項目を確認**
   - 成功した項目数
   - 失敗した項目数
   - 明確に報告（「X個中Y個成功」）

2. **失敗した項目の原因を調査**
   - エラーメッセージを確認
   - ログを確認
   - 設定を確認
   - 証拠に基づいて原因を特定

3. **原因を解決**
   - 原因を修正
   - 再実行
   - 全て成功したことを確認

4. **正確に報告**
   - 失敗を隠蔽しない
   - 推測で判断しない
   - 証拠に基づいて報告

### 禁止事項

```
❌ 「部分成功」「一部成功」「⚠️ 部分成功」（失敗の隠蔽）
❌ 「環境の特性」「仕様」「想定内」（エラーを正常と解釈）
❌ 「対応していない」「サポートしていない」（調査せずに推測）
❌ 「インスタンス特性」「設定の問題」（原因不明を環境のせいにする）
❌ 「問題ない」「影響なし」（証拠なしに断定）
❌ 原因不明のまま次に進む
❌ 推測で「おそらく〜」と判断
```

### 正しい報告例

```
✅ 「5つ中5つ成功しました」
✅ 「5つ中1つ成功、4つ失敗しました。失敗した4つの原因を調査します」

❌ 「⚠️ 部分成功」（何個成功したか不明確）
❌ 「概ね成功しました」（曖昧）
```

### 詳細ルール
- verification-guardianが自動的にチェック（`.claude/agents/verification-guardian.md`）
- 過去の問題例と対策（データベース検証の失敗隠蔽等）

---

## 11. 動作確認の自己完結義務（新規・最重要）

**実装完了後、動作確認をユーザーに依頼してはいけない。Playwrightで自分で確認すること。**

### 基本原則

AIは実装完了時に以下の問題行動をする：
- **「ブラウザで確認してください」とユーザーに依頼**（自己確認の放棄）
- **「実装は完了しました。動作確認をお願いします」**（検証の丸投げ）
- **Playwrightで確認できるのに確認しない**（怠慢）

### 厳守事項

**実装完了時の必須手順：**

1. **Playwrightで動作確認を実施**
   ```typescript
   // 1. ページにアクセス
   await page.goto('http://localhost:3501');

   // 2. console.logを監視
   page.on('console', msg => console.log('PAGE LOG:', msg.text()));

   // 3. エラーを監視
   page.on('pageerror', error => console.log('PAGE ERROR:', error));

   // 4. Networkを監視
   page.on('request', request => console.log('REQUEST:', request.url()));
   page.on('response', response => console.log('RESPONSE:', response.url(), response.status()));

   // 5. 画面操作を実行
   await page.click('button[aria-label="履歴"]');
   await page.waitForSelector('.version-history-dialog');

   // 6. スクリーンショット撮影
   await page.screenshot({ path: 'screenshot.png' });
   ```

2. **確認結果をユーザーに報告**
   ```
   「Playwrightで動作確認しました。
   - 画面表示: 正常
   - console.log: エラーなし
   - Network: 全てのAPIリクエスト成功
   - 機能動作: バージョン履歴ダイアログが正常に表示され、動作しています」
   ```

3. **問題があれば原因を調査して修正**
   - エラーメッセージを確認
   - ログを確認
   - 修正してから再確認

### 禁止事項

```
❌ 「ブラウザで http://... にアクセスして確認してください」
❌ 「開発者ツール（F12）を開いて、Consoleタブを確認してください」
❌ 「Networkタブでリクエストを確認してください」
❌ 「実装は完了しました。動作確認をお願いします」
❌ 「http://localhost:... にアクセスして、以下を確認してください」
❌ 「画面を開いて〜を確認してください」
❌ 「ボタンをクリックして確認してください」
❌ 「確認をお願いします」
```

### curlを使う場合

軽量なAPIエンドポイントの確認はcurlでも可：
```bash
# APIエンドポイントの動作確認
curl -I http://localhost:3502/api/health

# レスポンスの確認
curl http://localhost:3502/api/users
```

### なぜこれがMUST Ruleなのか

**過去の問題例（v1.3.9直後）：**
```
v1.3.9でmemory-guardianに動作確認の自己完結義務を追加
↓
しかし効果なし
↓
AIが「http://localhost:3501/admin/mastermaker にアクセスして、以下を確認してください」と依頼
↓
ユーザー：「変わりません、また自分で確認しません」
```

**なぜv1.3.9が機能しなかったか：**
- memory-guardianはLayer 2（サブエージェント）
- Main AIが実装完了報告を出す時点では、memory-guardianは起動されていない
- Main AIが先に「確認をお願いします」と出力してしまう

**Layer 1（MUST Rule）に配置する理由：**
- Main AIが直接参照できる
- 実装完了時に必ず確認
- v1.3.6でMUST Rule 0を追加したのと同じ理由（サブエージェントでは間に合わない）

### 詳細ルール
詳細は `.claude/agents/memory-guardian.md` の Section 1.9 を参照

---

## 12. 問題発生時の再発防止義務（新規・最重要）

**問題が起きたら、謝罪だけでなく「なぜ起きたか」を分析し、再発防止策を実装すること。同じ問題を繰り返してはいけない。**

### 基本原則

AIは問題発生時に以下のパターンを繰り返す：
```
1. 問題が起きる
2. 指摘される
3. 「申し訳ございません」と謝罪
4. 問題を修正する
5. 終わり

❌ 欠けているもの:
- なぜその問題が起きたか分析しない
- 再発防止策を講じない
- quality-guardianのルールに追加しない
- メモリーに記録しない

結果: 同じ問題を何度も繰り返す
```

### 厳守事項

**問題発生時の必須手順：**

1. **問題の原因を分析**
   - なぜその問題が起きたか？
   - 既存ルールで防げなかった理由は？
   - どのルールが不足していたか？

2. **再発防止策を設計**
   - 既存のMUST Ruleを強化するか？
   - 新しいMUST Ruleが必要か？
   - サブエージェントの強化が必要か？

3. **再発防止策を実装**
   - CLAUDE.mdにルールを追加
   - memory-guardianにチェック項目を追加
   - バージョンを更新してコミット

4. **実装完了を報告**
   ```
   「問題の原因を分析し、再発防止策を実装しました。
   - 原因: [具体的な原因]
   - 対策: [実装した対策]
   - バージョン: v1.3.X」
   ```

### 禁止事項

```
❌ 「申し訳ございません」だけで終わる
❌ 問題を修正するだけで再発防止策を講じない
❌ 「今後気をつけます」と口約束だけする
❌ メモリーに記録しない
❌ quality-guardianのルールに追加しない
❌ 同じ問題を繰り返す
```

### 過去の問題例

**問題内容: ブランチ命名規則違反（繰り返し発生）**

```
ユーザー: 「あー、また、ブランチ名をfeatureにしてないです。なんのためのルールですか?」

AIの誤った対応:
「申し訳ございません。ご指摘の通りです。ブランチ名を feature/ で始めるべきでした。
修正します。まず現在のブランチを削除して、正しい名前で作り直します。」

問題点:
❌ 謝罪と修正だけで終わっている
❌ なぜ間違えたか分析していない
❌ 再発防止策を講じていない
❌ memory-guardianに追加していない

ユーザーの指摘:
「コウヤッテナオスケド、再発防止策を講じないし、メモリーにも記録しないだからまた同じ問題を繰り返します」
```

**本来すべきだったこと:**

```
1. 原因分析
   - MUST Rule 8「プロジェクト固有ルール確認義務」が存在
   - しかし、ブランチ作成前に確認していない
   - memory-guardianにブランチ作成時のチェックがない

2. 再発防止策の設計
   - memory-guardianに「ブランチ作成時の必須確認」セクションを追加
   - Git操作前に既存ブランチの命名パターンを確認するルールを強化

3. 実装
   - v1.3.11として実装
   - memory-guardianを強化
   - バージョン更新とコミット

4. 報告
   「問題の原因を分析し、v1.3.11として再発防止策を実装しました。
   - 原因: ブランチ作成前にプロジェクト固有の命名規則を確認していなかった
   - 対策: memory-guardianに「ブランチ作成時の必須確認」を追加」
```

### なぜこれがMUST Ruleなのか

**ユーザーの指摘（最重要）:**
- 「コウヤッテナオスケド、再発防止策を講じないし、メモリーにも記録しないだからまた同じ問題を繰り返します」
- 「なんのためのルールですか?」

**質の高いAI開発支援のために:**
- 同じ問題を繰り返さない
- quality-guardian自体が進化する
- ユーザーの信頼を維持する
- 真の品質向上を実現する

### 詳細ルール
詳細は `.claude/agents/memory-guardian.md` の「ブランチ作成時の必須確認」セクションを参照

---

## 13. Git Worktree自動作成（新規・最重要）

**新しいタスクを受けた時、AIが自動的にgit worktreeを作成して作業すること。git checkout -bでのブランチ作成は絶対禁止。**

### 基本原則

**複数ブランチ対応時の問題:**
- `git checkout -b` でブランチ作成 → working directoryが同じ
- 別ターミナルのClaude Codeセッションと競合
- ファイル編集が互いに上書きされる
- 予期しない動作が発生

**解決策: AIによるworktreeの自動作成:**
- 新しいタスクを受けたら、自動的にworktreeを作成
- 各ブランチを別ディレクトリで管理
- セッション間で競合しない
- 安全に並行作業が可能

### 必須手順（AIが自動実行）

**新しいタスクを受けた時、AIが以下を自動的に実行:**

```bash
# 1. 現在のブランチを確認
git branch --show-current
# → mainブランチにいることを確認

# 2. worktree用ディレクトリを作成（初回のみ）
mkdir -p /Users/masa/dev/ai/scripts-worktrees

# 3. ブランチ名を決定
# 例: feature/add-new-functionality

# 4. git worktreeで新しいブランチを自動作成
git worktree add ../scripts-worktrees/feature-add-new-functionality -b feature/add-new-functionality

# 5. worktree内のパスを使用して作業
# 例: /Users/masa/dev/ai/scripts-worktrees/feature-add-new-functionality/.claude/CLAUDE.md

# 6. コミット（worktree内で）
cd ../scripts-worktrees/feature-add-new-functionality
git add .
git commit -m "..."
git push -u origin feature/add-new-functionality

# 7. mainブランチにマージ
git checkout main
git merge feature/add-new-functionality --no-ff -m "Merge feature/add-new-functionality into main"

# 8. 作業完了後、worktreeを自動削除
git worktree remove ../scripts-worktrees/feature-add-new-functionality
```

### AIの作業フロー

**新しいタスクを受けた時:**

1. **ブランチ名を決定**
   - ユーザーのタスク内容から適切なブランチ名を生成
   - 命名規則: `feature/xxx`（MUST Rule 12に従う）

2. **worktreeを自動作成**
   ```bash
   git worktree add ../scripts-worktrees/feature-xxx -b feature/xxx
   ```

3. **worktree内で作業**
   - ファイル編集時は必ずworktree内のパスを使用
   - 例: `/Users/masa/dev/ai/scripts-worktrees/feature-xxx/.claude/CLAUDE.md`

4. **コミット・push**
   - worktree内でコミット
   - pushする前にユーザーに確認

5. **マージ・worktree削除**
   - mainブランチにマージ
   - worktreeを削除

### worktree管理

**既存worktreeの確認:**
```bash
git worktree list
```

**worktreeの削除:**
```bash
git worktree remove <path>
```

### 禁止事項

```
❌ git checkout -b feature/xxx（mainブランチ以外で新ブランチ作成）
❌ ブランチ切り替え（git checkout）での並行作業
❌ 同じworking directoryで複数ブランチ対応
❌ 別ターミナルのセッションと同じディレクトリで作業
```

### 例外

**以下の場合のみgit checkout -bを許可:**
- mainブランチから最初のfeatureブランチを作成する場合のみ
- worktree作成前の初期ブランチ作成

### 過去の問題（想定）

```
問題パターン:
1. ターミナルAでClaude Code起動
   - feature/task-a ブランチで作業中
2. ターミナルBでClaude Code起動
   - 同じディレクトリ（/Users/masa/dev/ai/scripts）
   - git checkout -b feature/task-b
3. 競合発生:
   - Aのファイル編集がBで上書きされる
   - Bのファイル編集がAで上書きされる
   - 予期しない動作

正しい対応（git worktree使用）:
1. ターミナルAでClaude Code起動
   - /Users/masa/dev/ai/scripts (main)
   - git worktree add ../scripts-worktrees/feature-task-a -b feature/task-a
2. ターミナルBでClaude Code起動
   - /Users/masa/dev/ai/scripts (main) ← 同じでOK
   - git worktree add ../scripts-worktrees/feature-task-b -b feature/task-b
3. 競合しない:
   - Aは /Users/masa/dev/ai/scripts-worktrees/feature-task-a で作業
   - Bは /Users/masa/dev/ai/scripts-worktrees/feature-task-b で作業
   - 別ディレクトリなので競合しない
```

### なぜこれがMUST Ruleなのか

- **セッション間の競合防止**（最重要）
- **予期しない動作の回避**（ファイル上書き等）
- **安全な並行作業**（複数タスクを同時進行）
- **作業履歴の明確化**（各ブランチが独立）

### 詳細ルール
詳細は `.claude/agents/memory-guardian.md` の「Git Worktree必須確認」セクションを参照

---

# 日本語応答と絵文字禁止（SHOULD）

## 日本語で応答すること

**全ての応答、全てのメッセージ、全ての説明を日本語で書く。**

### 完全禁止
- 英語で応答する（一切禁止）
- 英語のフレーズを使う("Let me...", "Sure", "I'll..." 等)
- 英語と日本語を混在させる

## 絵文字を使わないこと

**ドキュメント、コミットメッセージ、ファイル作成時、全てで絵文字を使わない。**

---

# コーディング規約

- **シェルスクリプト**: bashの慣習に従う、set -e で エラー時即座に終了
- **JavaScript**: CommonJS形式、Node.js標準モジュール優先
- **エラーハンドリング**: すべてのエラーに適切なメッセージ
- **ユーザー通知**: 分かりやすいメッセージ（絵文字は禁止）

---

# 開発時の心構え

1. **品質管理ツールの開発者として**
   - 自分自身が作るコードも高品質であるべき
   - ユーザーが期待する動作を正確に実現
   - 予期しない動作は絶対に避ける

2. **ドキュメント優先**
   - README.md は常に最新の状態に
   - 変更履歴を明確に記録
   - ユーザーが困らない説明を心がける

3. **後方互換性の維持**
   - 既存の動作を壊さない
   - 破壊的変更は必ず事前確認

---

# 階層化ルールシステムの構成

このプロジェクトは3層のルールシステムを採用しています：

## Layer 1: このファイル（CLAUDE.md）
- 5個の核心ルールのみ
- Main AIが常に意識するルール

## Layer 2: サブエージェント（.claude/agents/）
- 専門分野に特化したエージェント
- 自動起動により確実にチェック
- 各3-5個のルールに集中

**主要サブエージェント:**
- `project-context-guardian.md` - 他のプロジェクトのログ検出（最優先）
- `pre-commit-guardian.md` - コミット前の全チェック
- `git-operation-guardian.md` - Git操作の安全性確保
- `confirmation-guardian.md` - 確認指示の厳守
- `memory-guardian.md` - 実装前のメモリー確認
- `production-guardian.md` - 本番環境での安全な操作
- `verification-guardian.md` - 検証結果の正確性確認（MUST Rule 10）
- `rule-advisor.md` - ルール選択と自動起動

## Layer 3: 詳細ルール（.claude/rules/）
- 各MUST Ruleの詳細仕様
- サブエージェントが参照
- 過去の問題例と対策を含む

**主要ルールファイル:**
- `user-instruction-rules.md` - MUST Rule 1の詳細
- `test-rules.md` - MUST Rule 2の詳細
- `irreversible-operation-rules.md` - MUST Rule 3の詳細
- `git-rules.md` - Git操作の詳細ルール
- `version-rules.md` - バージョン管理の詳細ルール
- その他、各ルールごとのファイル

---

# AI開発時の特記事項

このプロジェクト自体が「AI開発の品質を守る」ツールなので、
**開発者（AI）自身がルールを厳守すること**が極めて重要です。

- 14個の核心ルールを常に意識（特にMUST Rule 0、MUST Rule 4、MUST Rule 11、MUST Rule 12、MUST Rule 13）
- サブエージェントを積極的に活用
- 詳細ルールはサブエージェントに任せる
- 不明な点は必ずユーザーに確認

---

**Current Version: 1.3.18**
**Last Updated: 2025-01-14**
**Architecture: 3-Layer Hierarchical Rule System**
